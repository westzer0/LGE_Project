# 백엔드 로직 전체 요약

## 📋 목차
1. [아키텍처 개요](#아키텍처-개요)
2. [데이터베이스 모델](#데이터베이스-모델)
3. [API 엔드포인트](#api-엔드포인트)
4. [추천 엔진 로직](#추천-엔진-로직)
5. [필터링 로직](#필터링-로직)
6. [스코어링 로직](#스코어링-로직)
7. [추천 문구 생성](#추천-문구-생성)

---

## 🏗️ 아키텍처 개요

### 전체 구조
```
Django 백엔드
├── Models (데이터베이스 모델)
├── Views (API 엔드포인트)
├── Services (비즈니스 로직)
│   ├── RecommendationEngine (추천 엔진)
│   ├── RecommendationReasonGenerator (추천 문구 생성)
│   └── ChatGPTService (AI 연동)
├── Utils (유틸리티)
│   ├── ProductFilters (필터링)
│   ├── Scoring (점수 계산)
│   └── TasteScoring (취향별 점수)
└── RuleEngine (규칙 엔진)
```

### 추천 플로우
```
1. 사용자 온보딩 데이터 입력
   ↓
2. Hard Filtering (엄격한 필터링)
   - 카테고리 필터
   - 가격 범위 필터
   - 가족 구성 기반 용량 필터
   - 주거 형태/평수 기반 크기 필터
   - 생활 패턴 기반 필터
   - 우선순위 기반 필터
   ↓
3. Soft Scoring (가중치 기반 점수 계산)
   - 스펙 기반 점수
   - 사용자 취향 기반 점수
   - 우선순위 기반 점수
   ↓
4. 정렬 및 상위 K개 선택
   ↓
5. 추천 문구 생성
   ↓
6. API 응답 반환
```

---

## 💾 데이터베이스 모델

### 주요 모델

#### 1. Product (제품)
```python
- name: 제품명
- model_number: 모델명
- category: 카테고리 (TV, KITCHEN, LIVING, AIR, AI, OBJET, SIGNATURE)
- price: 가격
- discount_price: 할인가
- image_url: 이미지 URL
- is_active: 판매중 여부
```

#### 2. ProductSpec (제품 스펙)
```python
- product: Product와 1:1 관계
- spec_json: JSON 형태의 스펙 데이터
```

#### 3. OnboardingSession (온보딩 세션)
```python
- session_id: 고유 세션 ID
- vibe: 인테리어 무드 (modern, cozy, pop, luxury)
- household_size: 가구 인원수
- housing_type: 주거 형태 (apartment, detached, villa, officetel, studio)
- pyung: 주거 평수
- priority: 구매 우선순위 (design, tech, eco, value)
- budget_level: 예산 범위 (low, medium, high)
- selected_categories: 선택한 카테고리 목록
- recommendation_result: 추천 결과 (JSON)
```

#### 4. Portfolio (포트폴리오)
```python
- portfolio_id: 포트폴리오 ID
- user_id: 사용자 ID
- style_type: 스타일 유형
- products: 추천 제품 목록 (JSON)
- total_original_price: 정가 합계
- total_discount_price: 할인가 합계
- match_score: 매칭 점수
```

#### 5. ProductReview (제품 리뷰)
```python
- product: Product와 1:N 관계
- review_text: 리뷰 내용
- star: 별점
```

---

## 🔌 API 엔드포인트

### 온보딩 API

#### `POST /api/onboarding/step/`
온보딩 단계별 데이터 저장
```json
{
  "session_id": "abc12345",
  "step": 2,
  "data": {
    "household_size": 4,
    "vibe": "modern"
  }
}
```

#### `POST /api/onboarding/complete/`
온보딩 완료 → 자동 추천 실행
```json
{
  "session_id": "abc12345",
  "vibe": "modern",
  "household_size": 4,
  "housing_type": "apartment",
  "pyung": 30,
  "priority": "tech",
  "budget_level": "medium",
  "selected_categories": ["TV", "KITCHEN"]
}
```

#### `GET /api/onboarding/session/<session_id>/`
온보딩 세션 조회

### 추천 API

#### `POST /api/recommend/`
제품 추천 API
```json
{
  "vibe": "modern",
  "household_size": 4,
  "housing_type": "apartment",
  "pyung": 30,
  "priority": "tech",
  "budget_level": "medium",
  "categories": ["TV", "KITCHEN"],
  "has_pet": false,
  "cooking": "sometimes",
  "laundry": "weekly",
  "media": "balanced"
}
```

응답:
```json
{
  "success": true,
  "count": 3,
  "recommendations": [
    {
      "product_id": 1,
      "name": "LG OLED55C5",
      "category": "TV",
      "price": 1500000,
      "discount_price": 1200000,
      "image_url": "...",
      "score": 0.85,
      "reason": "추천 이유 문구"
    }
  ]
}
```

### 제품 API

#### `GET /api/products/`
제품 목록 조회 (category 쿼리 파라미터 지원)

#### `GET /api/products/<product_id>/spec/`
제품 스펙 조회

#### `GET /api/products/image-by-name/?name=제품명`
제품명으로 이미지 URL 조회

### 포트폴리오 API

#### `POST /api/portfolio/save/`
포트폴리오 저장

#### `GET /api/portfolio/<portfolio_id>/`
포트폴리오 상세 조회

#### `GET /api/portfolio/list/?user_id=xxx`
사용자 포트폴리오 목록 조회

#### `POST /api/portfolio/<portfolio_id>/share/`
포트폴리오 공유

### AI API

#### `POST /api/ai/recommendation-reason/`
AI 추천 이유 생성

#### `POST /api/ai/style-message/`
AI 스타일 메시지 생성

#### `POST /api/ai/review-summary/`
AI 리뷰 요약

#### `POST /api/ai/chat/`
AI 상담 챗봇

#### `GET /api/ai/status/`
AI 서비스 상태 확인

---

## 🎯 추천 엔진 로직

### RecommendationEngine 클래스

**위치**: `api/services/recommendation_engine.py`

#### 주요 메서드

##### `get_recommendations(user_profile, limit=3)`
최종 추천 반환 메인 로직

**프로세스:**
1. 입력 검증 (`_validate_user_profile`)
2. Hard Filtering (`_filter_products`)
3. Soft Scoring (`_score_products`)
4. 정렬 및 상위 K개 선택
5. 최종 포맷팅 (`_format_recommendation`)

##### `_filter_products(user_profile)`
엄격한 필터링 적용

**필터링 조건:**
- 카테고리 필터 (선택한 카테고리만)
- 가격 범위 필터 (budget_level 기반)
- 스펙 존재 필터 (ProductSpec이 있는 제품만)
- 반려동물 필터 (펫 전용 제품 제외)
- 가족 구성 기반 용량 필터
- 주거 형태/평수 기반 크기 필터
- 생활 패턴 기반 필터
- 우선순위 기반 필터

##### `_score_products(products, user_profile)`
가중치 기반 점수 계산

**스코어링 함수 호출:**
- `calculate_product_score()`: 기본 스코어링
- `calculate_product_score_with_taste_logic()`: 취향별 스코어링

##### `_format_recommendation(item, user_profile)`
최종 추천 결과 포맷팅

**포함 정보:**
- 제품 기본 정보
- 추천 점수
- 추천 이유 (RecommendationReasonGenerator 사용)

---

## 🔍 필터링 로직

### ProductFilters 모듈

**위치**: `api/utils/product_filters.py`

#### 주요 필터링 함수

##### `filter_by_household_size(product, household_size)`
가족 구성에 따른 용량 필터

**규칙:**
- **냉장고**
  - 1인 가구: 200L 이상 제외
  - 2인 가구: 900L 이상 제외
  - 4인 이상: 300L 미만 제외
- **세탁기**
  - 1인 가구: 7kg 이상 제외
  - 2인 가구: 15kg 이상 제외
  - 4인 이상: 4kg 미만 제외
- **건조기**
  - 1인 가구: 10kg 이상 제외
  - 4인 이상: 5kg 미만 제외

##### `filter_by_housing_type(product, housing_type, pyung)`
주거 형태/평수에 따른 크기 필터

**규칙:**
- **원룸/오피스텔**
  - 냉장고: 500L 이상 제외
  - TV: 55인치 이상 제외
- **아파트**
  - 20평 이하: 냉장고 600L 이상, TV 65인치 이상 제외
  - 20~30평: 냉장고 900L 이상, TV 85인치 이상 제외

##### `filter_by_lifestyle(product, user_profile)`
생활 패턴 기반 필터

**규칙:**
- 요리 빈도가 낮으면: 전기레인지 제외
- 세탁 빈도가 낮으면: 세탁기, 건조기, 워시타워 제외
- 미디어 사용이 적으면: TV, 오디오 제품 제외

##### `filter_by_priority(product, user_profile)`
우선순위 기반 필터

**규칙:**
- 에너지 효율 우선: 3등급 이하 제외
- 가성비 우선: SIGNATURE, 프리미엄 제품 제외

##### `apply_all_filters(products, user_profile)`
모든 필터를 적용하여 제품 목록 필터링

---

## 📊 스코어링 로직

### Scoring 모듈

**위치**: `api/utils/scoring.py`

#### 점수 계산 구조

##### 🎯 취향 조합별 완전히 다른 가중치 구조 (핵심 개선)

사용자의 **취향 조합(vibe + priority)**에 따라 완전히 다른 가중치 구조를 적용합니다.

**예시:**
- **Modern + Tech**: 해상도 35%, 주사율 25%, 가격 5% (기술 최우선)
- **Cozy + Value**: 가격 40%, 에너지효율 25%, 용량 20% (가성비 최우선)
- **Luxury + Design**: 디자인 40%, 패널타입 25%, 기능 20% (디자인 최우선)

**주요 취향 조합별 가중치:**

| 취향 조합 | TV 가중치 예시 | KITCHEN 가중치 예시 |
|-----------|----------------|---------------------|
| Modern + Tech | 해상도 35%, 주사율 25%, 밝기 20%, 가격 5% | 기능 35%, 용량 25%, 디자인 15%, 가격 10% |
| Modern + Design | 디자인 40%, 패널타입 25%, 해상도 15%, 가격 10% | 디자인 40%, 용량 20%, 기능 20%, 가격 10% |
| Cozy + Value | 가격 40%, 전력효율 25%, 크기 15%, 해상도 10% | 가격 40%, 용량 25%, 에너지효율 20%, 디자인 5% |
| Cozy + Eco | 전력효율 35%, 에너지효율 25%, 디자인 20%, 가격 10% | 에너지효율 40%, 전력효율 25%, 디자인 15%, 용량 10% |
| Luxury + Design | 디자인 40%, 패널타입 25%, 해상도 15%, 가격 10% | 디자인 40%, 기능 25%, 용량 20%, 가격 15% |
| Luxury + Tech | 해상도 30%, 밝기 25%, 주사율 20%, 패널타입 15% | 기능 35%, 용량 25%, 디자인 20%, 에너지효율 20% |

이렇게 취향별로 완전히 다른 가중치를 적용하여 **개인화된 추천**을 제공합니다.

##### 카테고리별 기본 가중치 (취향 조합이 없을 때)

**TV 카테고리:**
- 해상도: 0.25
- 밝기: 0.15
- 주사율: 0.15
- 패널 타입: 0.10
- 전력소비: 0.10
- 크기: 0.10
- 가격 적합도: 0.15

**KITCHEN 카테고리:**
- 용량: 0.25
- 에너지 효율: 0.20
- 기능: 0.15
- 크기: 0.10
- 가격 적합도: 0.20
- 디자인: 0.10

**LIVING 카테고리:**
- 오디오 품질: 0.25
- 연결성: 0.15
- 전력소비: 0.10
- 크기: 0.10
- 가격 적합도: 0.20
- 기능: 0.20

##### 취향 조합별 가중치 적용 로직

**우선순위:**
1. 취향 조합별 가중치 확인 (`vibe` + `priority`)
2. 취향 조합별 가중치가 있으면 → 해당 가중치 직접 사용 (multiplier 적용 안 함)
3. 취향 조합별 가중치가 없으면 → 기본 카테고리별 가중치 사용 + Priority multiplier 적용

**코드 흐름:**
```python
# 취향 조합 키 생성
taste_key = (vibe.lower(), priority.lower())

# 취향 조합별 가중치 확인
if taste_key in TASTE_COMBINATION_WEIGHTS:
    weights = TASTE_COMBINATION_WEIGHTS[taste_key][category]
else:
    # 기본 가중치 사용
    weights = CATEGORY_WEIGHTS[category]
    # Priority multiplier 적용
    multipliers = PRIORITY_MULTIPLIERS.get(priority, {})
```

**예시:**

```python
# Modern + Tech 사용자의 TV 추천
vibe = "modern"
priority = "tech"
taste_key = ("modern", "tech")

# 취향 조합별 가중치 직접 적용
weights = {
    "resolution": 0.35,      # 해상도가 최우선 (35%)
    "refresh_rate": 0.25,    # 주사율이 중요 (25%)
    "brightness": 0.20,      # 밝기 (20%)
    "panel_type": 0.10,      # 패널 타입 (10%)
    "features": 0.05,        # 기능 (5%)
    "price_match": 0.05,     # 가격은 낮은 가중치 (5%)
}

# Cozy + Value 사용자의 KITCHEN 추천
taste_key = ("cozy", "value")
weights = {
    "price_match": 0.40,     # 가격이 최우선 (40%)
    "energy_efficiency": 0.25,  # 에너지 효율 (25%)
    "capacity": 0.20,        # 용량 (20%)
    "design": 0.15,          # 디자인 (15%)
}
```

##### 우선순위별 가중치 조정 (기본 가중치 사용 시만)

취향 조합별 가중치가 정의되지 않은 경우에만 적용됩니다.

**Design 우선:**
- 디자인: 1.5배
- 패널 타입: 1.3배
- 기능: 1.2배

**Tech 우선:**
- 해상도: 1.5배
- 주사율: 1.4배
- 밝기: 1.3배
- 기능: 1.2배

**Eco 우선:**
- 전력소비: 1.5배
- 에너지 효율: 1.5배

**Value 우선:**
- 가격 적합도: 1.5배
- 기능: 1.2배

#### 주요 스코어링 함수

##### `score_resolution(spec, profile)`
해상도 점수 (4K > QHD > FHD > HD)

##### `score_brightness(spec, profile)`
밝기 점수 (nit 기준)

##### `score_capacity(spec, profile, product)`
용량 적합도 점수

**규칙:**
- 가구 인원수 기반 적정 용량 계산
- 1인 가구에게 대형 용량 강한 감점
- 4인 이상 가족에게 대형 용량 가산점

##### `score_price_match(product, profile)`
예산 대비 가격 적합도

##### `score_design(product, profile)`
디자인 점수 (vibe 기반)

**Vibe별 디자인 점수:**
- Modern: OBJET > SIGNATURE > default
- Luxury: SIGNATURE > OBJET > default
- Cozy: OBJET > default

##### `score_features(spec, product, profile)`
기능 점수

**펫 기능:**
- 반려동물 있는 경우: 펫 기능 가산점 (+0.2)
- 반려동물 없는 경우: 펫 기능 감점 (-0.4)

#### 최종 점수 계산

##### `calculate_product_score(product, profile)`

**프로세스:**
1. 카테고리별 가중치 적용
2. 우선순위별 가중치 조정
3. 각 스펙 점수 계산
4. 가중 평균 계산
5. 우선순위별 추가 보정
6. Vibe별 추가 보정
7. 가족 인원/반려동물 기반 추가 조정

**최종 점수 범위**: 0.0 ~ 1.0

---

## 💬 추천 문구 생성

### RecommendationReasonGenerator 클래스

**위치**: `api/services/recommendation_reason_generator.py`

#### 추천 문구 생성 우선순위

1. **취향 조합별 1:1 템플릿 매칭**
   - (vibe, priority, household_category) 조합별 템플릿
   - 가장 정확한 매칭

2. **CSV의 리뷰 기반 추천문구 활용**
   - taste_info가 있는 경우
   - 개인화 처리 적용

3. **DB에 저장된 추천 이유 활용**
   - ProductRecommendReason 모델 사용
   - 개인화 처리 적용

4. **리뷰 분석 기반 생성**
   - 제품 리뷰에서 취향 키워드 매칭
   - 긍정 키워드 추출

5. **기본 문구 생성**
   - 점수 기반 기본 문구

#### 취향 조합별 템플릿 예시

**Modern + Tech 조합:**
- 1인 가구: "1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요..."
- 2인 가구: "2인 가구를 위한 모던한 디자인과 최신 기술이 만난 제품이에요..."
- 가족: "가족을 위한 모던한 디자인과 최신 기술이 결합된 제품이에요..."

**Cozy + Value 조합:**
- 1인 가구: "1인 가구를 위한 따뜻한 분위기와 합리적인 가격이 매력적인 제품이에요..."
- 2인 가구: "2인 가구를 위한 따뜻하고 포근한 분위기와 합리적인 가격이 매력적인 제품이에요..."
- 가족: "4인 이상 가족을 위한 따뜻한 분위기와 넉넉한 용량, 합리적인 가격이 매력적인 제품이에요..."

---

## 🎨 주요 특징

### 1. 다단계 필터링
- Hard Filtering: 조건에 맞지 않는 제품 완전 제외
- Soft Scoring: 조건에 맞는 제품들을 점수로 정렬

### 2. 개인화 추천
- 사용자 취향 기반 스코어링
- 가족 구성원 수 기반 용량 필터링
- 주거 형태/평수 기반 크기 필터링
- 생활 패턴 기반 필터링
- 우선순위 기반 필터링 및 가중치 조정

### 3. 추천 문구 생성
- 취향 조합별 1:1 템플릿 매칭
- 리뷰 분석 기반 개인화
- 제품별 맞춤 문구 생성

### 4. 확장 가능한 구조
- Service Layer로 비즈니스 로직 분리
- Utils로 유틸리티 함수 모듈화
- Singleton 패턴으로 인스턴스 관리

---

## 📝 주요 파일 구조

```
api/
├── models.py                          # 데이터베이스 모델
├── views.py                           # API 엔드포인트
├── views_drf.py                       # DRF API 엔드포인트
├── rule_engine.py                     # 규칙 엔진
├── services/
│   ├── recommendation_engine.py       # 추천 엔진 서비스
│   ├── recommendation_reason_generator.py  # 추천 문구 생성
│   ├── chatgpt_service.py            # ChatGPT 연동
│   └── figma_to_code_service.py      # Figma 변환
├── utils/
│   ├── product_filters.py            # 제품 필터링
│   ├── scoring.py                    # 점수 계산
│   └── taste_scoring.py              # 취향별 점수 계산
└── serializers.py                    # DRF 시리얼라이저

config/
└── urls.py                           # URL 라우팅
```

---

## 🔄 데이터 흐름

### 추천 요청 처리 흐름

```
1. 클라이언트 → POST /api/recommend/
   {
     "vibe": "modern",
     "household_size": 4,
     ...
   }
   
2. views.py → recommend_view()
   - 요청 데이터 파싱
   - user_profile 생성
   
3. services/recommendation_engine.py → get_recommendations()
   - 입력 검증
   - Hard Filtering
   - Soft Scoring
   - 정렬 및 상위 K개 선택
   - 추천 문구 생성
   
4. utils/product_filters.py → apply_all_filters()
   - 가족 구성 필터
   - 주거 형태 필터
   - 생활 패턴 필터
   - 우선순위 필터
   
5. utils/scoring.py → calculate_product_score()
   - 스펙 기반 점수 계산
   - 가중치 적용
   - 최종 점수 계산
   
6. services/recommendation_reason_generator.py → generate_reason()
   - 취향 조합별 템플릿 매칭
   - 리뷰 분석
   - 개인화 처리
   
7. 응답 반환
   {
     "success": true,
     "count": 3,
     "recommendations": [...]
   }
```

---

## 🚀 성능 최적화

### 1. 쿼리 최적화
- 필요한 필드만 선택
- 인덱스 활용 (OnboardingSession, Portfolio)
- 스펙이 있는 제품만 필터링

### 2. 캐싱
- 리뷰 캐시 (RecommendationReasonGenerator)
- 제품 스펙 캐싱

### 3. 제한 처리
- 최대 50개 제품만 스코어링 처리
- 상위 K개만 반환

---

## 📌 주요 설정값

### 예산 범위 매핑
```python
'low': (0, 500000)
'medium': (500000, 2000000)
'high': (2000000, 10000000)
```

### 가족 구성별 적정 용량
- **냉장고**: 1인당 50-70L
- **세탁기**: 1인당 2-3kg

### 점수 범위
- 최종 점수: 0.0 ~ 1.0
- 각 스펙 점수: 0.0 ~ 1.0

---

이 문서는 백엔드 로직의 전체 구조를 이해하는 데 도움이 됩니다.
더 자세한 내용은 각 파일의 주석과 코드를 참고하세요.


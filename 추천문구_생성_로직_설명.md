# 추천 문구 생성 로직 설명

## 1. 768개 vs 400개의 차이

### 구조 설명

```
768개 취향 조합 (원본 데이터)
    ↓
[유사도 분석 및 클러스터링]
    ↓
약 400개 그룹 (Scoring Logic)
    ↓
각 그룹에 하나의 독립적인 Scoring Logic 할당
```

### 상세 설명

1. **768개 취향 조합**: 
   - `taste_recommendations_768.csv`에 저장된 원본 데이터
   - 인테리어 스타일 × 메이트 구성 × 우선순위 × 예산 범위의 모든 조합
   - 각 조합마다 고유한 `taste_id` (1~768)

2. **약 400개 그룹**:
   - 768개 취향 조합을 유사도 분석으로 클러스터링
   - 유사한 취향 조합들을 하나의 그룹으로 묶음
   - 각 그룹에 대해 하나의 독립적인 Scoring Logic 생성

3. **매핑 관계**:
   - 각 `taste_id`는 하나의 Scoring Logic 그룹에 매핑됨
   - 여러 `taste_id`가 같은 Logic을 공유할 수 있음
   - 예: taste_id 1, 2, 3이 모두 Logic 1을 사용

### 왜 시뮬레이션은 768개를 모두 실행했나?

- **원본 데이터**: 768개의 모든 취향 조합이 존재
- **Scoring Logic**: 약 400개로 그룹화되어 있지만
- **시뮬레이션 목적**: 각 취향 조합(taste_id)별로 실제 추천 결과를 확인
- 따라서 768개 케이스를 모두 실행하여 각 taste_id별 추천 결과를 분석

---

## 2. 각 케이스별 추천 문구 생성

### 목표
구매리뷰 분석 + 고객 취향 데이터 → 제품을 고객에게 추천하는 이유를 한 줄로 설명

### 데이터 소스
1. **구매리뷰**: `ProductReview` 모델 (실제 고객 리뷰)
2. **고객 취향**: `taste_recommendations_768.csv`의 취향 정보
3. **제품 정보**: 추천된 제품의 스펙 및 특징

### 생성 로직

#### 방법 1: 리뷰 기반 추천 문구 (기존 CSV 활용)
- CSV에 이미 "리뷰_기반_추천문구"가 있음
- 이를 그대로 활용하거나 개인화

#### 방법 2: 실시간 리뷰 분석 기반 생성
- 제품의 실제 리뷰를 분석
- 고객 취향과 매칭되는 키워드 추출
- 한 줄로 요약

#### 방법 3: 하이브리드 (권장)
- CSV의 추천 문구를 베이스로 사용
- 고객 취향 정보를 추가하여 개인화
- 제품별 리뷰 키워드로 보강

---

## 구현 계획

### 1. 추천 문구 생성 서비스 생성
- `api/services/recommendation_reason_generator.py`
- 리뷰 분석 + 취향 매칭 로직

### 2. 추천 엔진에 통합
- `recommendation_engine.py`의 `_build_recommendation_reason` 메서드 개선
- 각 taste_id별로 맞춤 추천 문구 생성

### 3. 시뮬레이션 결과에 추천 문구 추가
- 시뮬레이션 결과에 각 케이스별 추천 문구 포함


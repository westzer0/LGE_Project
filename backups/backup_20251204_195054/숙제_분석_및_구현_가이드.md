# 숙제 분석 및 구현 가이드

## 1. Figma 이미지 입력으로 프론트엔드 구현

### 구현 가능 여부: ✅ **구현 가능**

### 방법론

#### 접근 방식 1: Vision API 활용 (권장)
- **GPT-4 Vision** 또는 **Claude Vision** API 사용
- Figma 디자인 이미지를 업로드하여 분석
- 레이아웃, 색상, 폰트, 컴포넌트 구조 추출
- HTML/CSS/JavaScript 자동 생성

#### 구현 단계:
1. **이미지 업로드 엔드포인트 생성**
   ```python
   # api/views_drf.py에 추가
   @api_view(['POST'])
   def convert_figma_to_code(request):
       # Figma 이미지 파일 받기
       # Vision API로 분석
       # HTML/CSS 생성
       # 반환
   ```

2. **Vision API 통합**
   - OpenAI GPT-4 Vision 또는 Anthropic Claude Vision 사용
   - 프롬프트 엔지니어링으로 디자인 요소 추출
   - 구조화된 JSON 응답 받기

3. **코드 생성 로직**
   - 추출된 디자인 요소 → HTML 구조 변환
   - 색상, 폰트, 간격 → CSS 변환
   - 인터랙션 요소 → JavaScript 변환

#### 제한사항:
- 완벽한 1:1 매칭은 어려움 (약 70-80% 정확도)
- 복잡한 애니메이션이나 동적 요소는 수동 보완 필요
- 반복적인 수정 과정 필요

#### 대안: Figma API 직접 연동
- Figma REST API로 디자인 파일 직접 읽기
- 더 정확한 구조 정보 획득 가능
- 하지만 API 토큰 및 권한 설정 필요

---

## 2. 백엔드 추천 로직 구현

### 구현 상태: ✅ **이미 구현됨**

### 현재 구현 구조:

```
온보딩 데이터 (고객 취향)
    ↓
[RecommendationEngine.get_recommendations()]
    ↓
1. Hard Filtering (필터링)
   - 카테고리 필터
   - 가격 범위 필터
   - 스펙 존재 필터
   - 가족 인원 필터
   - 반려동물 필터
    ↓
2. Soft Scoring (점수 계산)
   - 제품 스펙 분석 (ProductSpec)
   - 인구통계 데이터 (ProductDemographics)
   - 리뷰 데이터 (ProductReview)
   - 평균벡터 (현재 미사용, 데이터만 존재)
    ↓
3. 최종 추천 반환
   - 점수 순 정렬
   - 상위 K개 선택
   - 추천 이유 생성
```

### 데이터 흐름:

#### 입력: 온보딩 데이터
```python
user_profile = {
    'vibe': 'modern',              # 인테리어 스타일
    'household_size': 4,           # 가족 구성원
    'housing_type': 'apartment',   # 주거 형태
    'pyung': 30,                   # 평수
    'priority': 'tech',            # 우선순위 (design/tech/eco/value)
    'budget_level': 'medium',      # 예산 수준
    'categories': ['TV', 'KITCHEN'], # 관심 카테고리
    'has_pet': False,              # 반려동물 여부
}
```

#### 사용되는 제품 데이터:
1. **제품 스펙 (ProductSpec)**
   - `api/models.py`의 `ProductSpec` 모델
   - JSON 형식의 상세 스펙 정보
   - 해상도, 용량, 전력소비, 에너지등급 등

2. **인구통계 데이터 (ProductDemographics)**
   - `api/models.py`의 `ProductDemographics` 모델
   - 가족 구성원별 선호도
   - 연령대별 선호도
   - 주거 형태별 선호도

3. **리뷰 데이터 (ProductReview)**
   - `api/models.py`의 `ProductReview` 모델
   - 실제 구매자 리뷰 텍스트
   - 추천 이유 생성에 활용

4. **평균벡터 데이터**
   - `data/리뷰_평균벡터/` 폴더에 CSV 파일 존재
   - 현재는 `generate_taste_recommendations.py`에서만 사용
   - 실제 추천 엔진에서는 미사용
   - **개선 필요**: 평균벡터를 활용한 유사도 계산 추가 가능

### 스코어링 로직:

#### 위치: `api/utils/scoring.py`
- 카테고리별 가중치 적용
- Priority별 가중치 조정
- Vibe별 디자인 점수
- 가족 구성원 기반 용량 적합도
- 반려동물 기반 기능 점수

#### 예시:
```python
# TV 카테고리 가중치
CATEGORY_WEIGHTS = {
    "TV": {
        "resolution": 0.25,      # 해상도
        "brightness": 0.15,      # 밝기
        "refresh_rate": 0.15,   # 주사율
        "panel_type": 0.10,     # 패널 타입
        "power_consumption": 0.10,
        "size": 0.10,
        "price_match": 0.15,
    }
}
```

### 개선 제안:

1. **평균벡터 활용**
   - 현재 평균벡터 데이터는 있지만 사용되지 않음
   - 코사인 유사도 계산으로 취향 매칭 강화 가능

2. **머신러닝 모델 통합**
   - 협업 필터링 (Collaborative Filtering)
   - 딥러닝 기반 추천 (Neural Collaborative Filtering)

---

## 3. 고객 취향과 추천 이유 1:1 텍스트 매칭

### 구현 상태: ✅ **부분 구현됨, 개선 필요**

### 현재 구현:

#### 위치: `api/services/recommendation_reason_generator.py`

#### 매칭 우선순위:
1. **CSV의 리뷰_기반_추천문구** (taste_info가 있는 경우)
2. **DB에 저장된 추천 이유** (ProductRecommendReason)
3. **리뷰 분석 기반 생성** (ProductReview 분석)
4. **기본 문구** (점수 기반)

### 현재 로직의 문제점:

1. **1:1 매칭이 약함**
   - 취향 정보와 추천 이유의 직접적인 연결이 부족
   - 키워드 기반 매칭만 사용

2. **개인화 수준이 낮음**
   - 사용자별 특성을 반영한 맞춤 문구 생성 미흡
   - 템플릿 기반 생성으로 다양성 부족

### 개선 방안:

#### 방법 1: 취향별 템플릿 매핑 (구현 가능)
```python
# 취향 조합별 추천 이유 템플릿 정의
TASTE_REASON_TEMPLATES = {
    ('modern', 'tech', 1): [
        "1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요.",
        "깔끔한 공간에 어울리는 컴팩트한 사이즈와 뛰어난 성능을 갖췄어요.",
    ],
    ('cozy', 'value', 4): [
        "4인 가족에게 적합한 넉넉한 용량과 합리적인 가격이 매력적인 제품이에요.",
        "따뜻한 분위기의 집에 어울리는 실용적인 가전이에요.",
    ],
    # ... 더 많은 조합
}
```

#### 방법 2: 벡터 유사도 기반 매칭 (구현 가능)
```python
# 1. 취향 정보를 벡터로 변환
taste_vector = embed_taste(user_profile)  # 예: [0.2, 0.8, 0.5, ...]

# 2. 추천 이유 후보들을 벡터로 변환
reason_vectors = [embed_reason(reason) for reason in candidate_reasons]

# 3. 코사인 유사도로 가장 유사한 이유 선택
best_reason = find_most_similar(taste_vector, reason_vectors)
```

#### 방법 3: LLM 기반 동적 생성 (구현 가능, 비용 발생)
```python
# ChatGPT API 활용
reason = chatgpt_service.generate_personalized_reason(
    product=product,
    user_profile=user_profile,
    taste_info=taste_info
)
```

### 권장 구현:

**하이브리드 접근법** (템플릿 + 벡터 유사도)
1. 취향 조합별 템플릿 우선 매칭
2. 템플릿이 없으면 벡터 유사도로 가장 유사한 이유 선택
3. 선택된 이유를 사용자 특성에 맞게 개인화

---

## 구현 우선순위

### 즉시 구현 가능:
1. ✅ **백엔드 추천 로직 문서화** (이미 구현됨)
2. ✅ **고객 취향-추천 이유 매칭 개선** (템플릿 기반)

### 중기 구현:
3. ⚠️ **Figma 이미지 → 코드 변환** (Vision API 통합 필요)
4. ⚠️ **평균벡터 활용 강화** (유사도 계산 추가)

### 장기 구현:
5. 🔄 **머신러닝 모델 통합** (협업 필터링 등)

---

## 다음 단계

1. **백엔드 로직 상세 문서 작성**
2. **추천 이유 매칭 로직 개선 구현**
3. **Figma 변환 프로토타입 개발**

각 항목에 대해 구체적인 구현 코드를 작성할까요?


# 추천 로직 정확한 설명

## 🎯 사용자가 이해한 로직 vs 실제 로직

### 사용자 이해:
1. 제품에 인구통계학적 정보, 가격정보 등 정량적인 데이터로 **sorting 후**
2. 온보딩이 완료된 사용자 별로 제품 칼럼에 스코어링이 다르게 배정
3. 스코어링이 완료된 제품 중 높은 점수가 해당 온보딩의 사용자에게 제일 적합하다고 판단하여 추천

### 실제 로직:
1. ✅ **Hard Filtering**: 조건에 맞는 제품만 **필터링** (sorting 아님!)
2. ✅ **Soft Scoring**: 사용자별로 각 제품에 **다른 점수** 부여
3. ✅ **정렬 및 선택**: 높은 점수 순으로 정렬 후 상위 선택

## 📋 단계별 상세 설명

### 1단계: Hard Filtering (필터링)
**"sorting"이 아니라 "filtering"이 정확합니다!**

```python
# api/services/recommendation_engine.py:91
filtered_products = self._filter_products(user_profile)
```

**이 단계에서는:**
- ❌ 정량적 데이터로 "sorting" (정렬) ❌
- ✅ 정량적 데이터로 "filtering" (필터링) ✅

**필터링 기준:**
- 카테고리: 사용자가 선택한 카테고리만 (예: ['TV'])
- 가격 범위: 예산 수준에 맞는 가격 범위 (예: 50만원 ~ 200만원)
- 스펙 존재: ProductSpec이 연결된 제품만
- 활성화 상태: `is_active=True`인 제품만

**결과:**
```
전체 제품 1000개
  ↓
[Hard Filtering]
  ↓
필터링된 제품 50개 (예: TV 카테고리, 50만~200만원 범위)
```

### 2단계: Soft Scoring (스코어링)
**사용자의 이해가 정확합니다! ✅**

```python
# api/services/recommendation_engine.py:101
scored_products = self._score_products(filtered_products, user_profile)
```

**이 단계에서는:**
- ✅ 온보딩 완료된 사용자별로
- ✅ 각 제품에 대해 스코어링이 **다르게** 배정됨

**점수 계산 요소:**
1. **해상도 점수** (TV인 경우)
   - 4K: 1.0점
   - FHD: 0.6점
   
2. **가격 적합도 점수**
   - 예산 범위 내: 높은 점수
   - 예산 초과: 감점

3. **가족 인원 점수** (사용자별로 다름!)
   - 1인 가구 → 소형 제품에 높은 점수
   - 4인 가구 → 대용량 제품에 높은 점수

4. **반려동물 점수** (사용자별로 다름!)
   - 반려동물 있음 → 펫 관련 기능 제품에 높은 점수
   - 반려동물 없음 → 펫 관련 기능 제품에 낮은 점수

5. **디자인 점수**
   - 스타일(vibe)에 맞는 디자인: 높은 점수

**예시:**
```
제품 A: LG 올레드 TV
- 사용자 A (1인 가구): 0.75점
- 사용자 B (4인 가구): 0.80점  ← 같은 제품도 사용자별로 다른 점수!
- 사용자 C (반려동물 있음): 0.70점
```

### 3단계: 정렬 및 선택
**사용자의 이해가 정확합니다! ✅**

```python
# api/services/recommendation_engine.py:107
top_products = sorted(
    scored_products,
    key=lambda x: x['score'],
    reverse=True  # 높은 점수 순으로
)[:limit]  # 상위 3개만
```

**이 단계에서는:**
- ✅ 스코어링이 완료된 제품들을 점수 순으로 정렬
- ✅ 높은 점수 = 해당 사용자에게 가장 적합한 제품

**결과:**
```
점수 순서:
1. 제품 B: 0.85점 ← 추천
2. 제품 A: 0.80점 ← 추천
3. 제품 C: 0.75점 ← 추천
4. 제품 D: 0.65점
5. 제품 E: 0.60점
...
```

## 🔄 전체 흐름 다이어그램

```
[전체 제품 DB] (예: 1000개)
    │
    ├─ 카테고리: TV, 냉장고, 세탁기...
    ├─ 가격: 10만원 ~ 1000만원
    └─ 스펙 정보: 있음/없음
    │
    ↓ [1단계: Hard Filtering]
    │
    [필터링된 제품] (예: 50개)
    │
    ├─ 카테고리: TV만 ✅
    ├─ 가격: 50만원 ~ 200만원 ✅
    └─ 스펙 정보: 있음 ✅
    │
    ↓ [2단계: Soft Scoring]
    │
    [스코어링된 제품] (50개)
    │
    ├─ 제품 1: 0.75점 (사용자 A 기준)
    ├─ 제품 2: 0.85점 (사용자 A 기준)
    ├─ 제품 3: 0.65점 (사용자 A 기준)
    └─ ...
    │
    ↓ [3단계: 정렬 및 선택]
    │
    [최종 추천] (상위 3개)
    │
    ├─ 1위: 제품 2 (0.85점)
    ├─ 2위: 제품 1 (0.75점)
    └─ 3위: 제품 3 (0.65점)
```

## 💡 핵심 차이점

### 사용자 이해에서 수정할 부분

| 사용자 이해 | 실제 로직 | 정확성 |
|------------|----------|--------|
| "정량적 데이터로 **sorting** 후" | "정량적 데이터로 **filtering** 후" | ❌ → ✅ |
| "사용자별로 스코어링이 다르게 배정" | "사용자별로 스코어링이 다르게 배정" | ✅ |
| "높은 점수 = 적합한 제품" | "높은 점수 = 적합한 제품" | ✅ |

### Sorting vs Filtering

**Sorting (정렬):**
- 모든 제품을 점수나 가격 순서로 나열
- 예: 가격 낮은 순, 높은 순

**Filtering (필터링):**
- 조건에 맞는 제품만 남김
- 예: TV 카테고리만, 50만원~200만원만

**우리 로직은 Filtering → Scoring → Sorting 순서입니다!**

## 📊 실제 코드 예시

### Step 1: Filtering (필터링)
```python
# 전체 제품 1000개 중에서
products = Product.objects.filter(
    category__in=['TV'],              # TV만
    price__gte=500000,                # 50만원 이상
    price__lte=2000000,               # 200만원 이하
    spec__isnull=False                # 스펙 있는 것만
)
# → 50개로 축소
```

### Step 2: Scoring (스코어링)
```python
# 50개 제품 각각에 점수 부여
for product in filtered_products:
    score = calculate_product_score(product, user_profile)
    # 사용자 A (1인 가구): 제품 1 → 0.75점
    # 사용자 B (4인 가구): 제품 1 → 0.80점  ← 같은 제품도 다른 점수!
```

### Step 3: Sorting & Selection (정렬 및 선택)
```python
# 점수 순으로 정렬
sorted_products = sorted(scored_products, key=lambda x: x['score'], reverse=True)
# → [0.85점, 0.80점, 0.75점, ...]

# 상위 3개만 선택
top_3 = sorted_products[:3]
# → [0.85점, 0.80점, 0.75점]
```

## ✅ 최종 정리

### 정확한 로직 순서:
1. **Hard Filtering** (필터링) 
   - 조건에 맞는 제품만 선택
   - sorting이 아니라 filtering!

2. **Soft Scoring** (스코어링)
   - 사용자별로 각 제품에 다른 점수 부여
   - 사용자 A: 제품 1 = 0.75점
   - 사용자 B: 제품 1 = 0.80점 (다름!)

3. **Sorting & Selection** (정렬 및 선택)
   - 높은 점수 순으로 정렬
   - 상위 K개만 선택

### 사용자 이해 수정:
- ❌ "정량적 데이터로 sorting 후"
- ✅ "정량적 데이터로 **filtering** 후"

나머지 2, 3단계는 정확합니다! 🎯


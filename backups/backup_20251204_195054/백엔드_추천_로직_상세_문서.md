# 백엔드 추천 로직 상세 문서

## 개요

온보딩 데이터(고객 취향)와 실제 제품 데이터(스펙, 인구통계, 리뷰, 평균벡터)를 이용하여 추천 데이터를 도출하는 전체 과정을 설명합니다.

---

## 데이터 흐름도

```
[온보딩 데이터] (고객 취향)
    ↓
[RecommendationEngine.get_recommendations()]
    ↓
┌─────────────────────────────────────┐
│ 1. Hard Filtering (필터링)          │
│    - 카테고리 필터                   │
│    - 가격 범위 필터                  │
│    - 스펙 존재 필터                  │
│    - 가족 인원 필터                  │
│    - 반려동물 필터                   │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 2. Soft Scoring (점수 계산)         │
│    - 제품 스펙 분석                  │
│    - 인구통계 데이터 활용             │
│    - 리뷰 데이터 분석                │
│    - 평균벡터 (향후 활용 예정)       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 3. 최종 추천 반환                    │
│    - 점수 순 정렬                    │
│    - 상위 K개 선택                   │
│    - 추천 이유 생성                  │
└─────────────────────────────────────┘
    ↓
[추천 결과 반환]
```

---

## 1. 입력 데이터: 온보딩 데이터 (고객 취향)

### 데이터 구조

```python
user_profile = {
    # 인테리어 스타일
    'vibe': 'modern',              # 'modern', 'cozy', 'luxury', 'unique'
    
    # 가족 구성
    'household_size': 4,           # 1, 2, 3, 4, 5, 6+
    
    # 주거 정보
    'housing_type': 'apartment',   # 'apartment', 'house', 'officetel'
    'pyung': 30,                   # 평수 (숫자)
    
    # 우선순위
    'priority': 'tech',            # 'design', 'tech', 'eco', 'value'
    
    # 예산
    'budget_level': 'medium',      # 'low', 'medium', 'high', 'luxury'
    
    # 관심 카테고리
    'categories': ['TV', 'KITCHEN'], # ['TV', 'KITCHEN', 'LIVING', 'AIR', 'AI', 'OBJET', 'SIGNATURE']
    
    # 반려동물
    'has_pet': False,              # True, False
    
    # 생활 패턴 (선택)
    'cooking': 'sometimes',       # 'daily', 'sometimes', 'rarely'
    'laundry': 'weekly',           # 'daily', 'weekly', 'biweekly'
}
```

### 데이터 소스

- **온보딩 세션**: `api/models.py`의 `OnboardingSession` 모델
- **CSV 파일**: `data/온보딩/taste_recommendations_768.csv`

---

## 2. 제품 데이터 소스

### 2.1 제품 스펙 (ProductSpec)

**위치**: `api/models.py`의 `ProductSpec` 모델

**데이터 형식**: JSON

**주요 필드**:
```json
{
    "해상도": "3,840 × 2,160",
    "밝기 (Typ.)": "800 nit",
    "주사율": "120Hz",
    "패널 타입": "OLED",
    "전력소비": "150W",
    "패널 크기": "55인치",
    "용량": "870L",
    "에너지등급": "1등급",
    ...
}
```

**활용 방법**:
- `api/utils/scoring.py`의 `parse_spec_json()` 함수로 파싱
- 카테고리별 가중치 적용하여 점수 계산
- 예: TV는 해상도, 밝기, 주사율 등이 중요

### 2.2 인구통계 데이터 (ProductDemographics)

**위치**: `api/models.py`의 `ProductDemographics` 모델

**데이터 내용**:
- 가족 구성원별 선호도 (1인, 2인, 3인, 4인+)
- 연령대별 선호도
- 주거 형태별 선호도

**활용 방법**:
- 현재는 **미사용** (향후 활용 예정)
- 가족 구성원 수와 제품의 인구통계 데이터를 매칭하여 점수 보정 가능

### 2.3 리뷰 데이터 (ProductReview)

**위치**: `api/models.py`의 `ProductReview` 모델

**데이터 내용**:
- 실제 구매자 리뷰 텍스트
- 리뷰 작성일
- 제품 ID

**활용 방법**:
- `api/services/recommendation_reason_generator.py`에서 활용
- 리뷰 텍스트에서 취향 키워드 추출
- 긍정 키워드 빈도 분석
- 추천 이유 생성에 활용

**예시**:
```python
# 리뷰에서 취향 키워드 찾기
taste_keywords = ['모던', '미니멀', '깔끔']
matched_keywords = find_matching_keywords(reviews, taste_keywords)
# → "리뷰에서 '깔끔'에 대한 긍정적 피드백이 15회 이상 나타났습니다."
```

### 2.4 평균벡터 데이터

**위치**: `data/리뷰_평균벡터/` 폴더

**파일 형식**: CSV, XLS

**데이터 내용**:
- 모델별 평균 벡터 (768차원)
- 추천 이유 텍스트

**현재 상태**: 
- ✅ 데이터 존재
- ❌ 실제 추천 엔진에서 **미사용**
- `api/management/commands/generate_taste_recommendations.py`에서만 사용

**향후 활용 방안**:
- 코사인 유사도 계산으로 취향 매칭 강화
- 벡터 유사도 기반 추천 이유 선택

---

## 3. 추천 로직 상세

### 3.1 Hard Filtering (필터링)

**위치**: `api/services/recommendation_engine.py`의 `_filter_products()` 메서드

**필터링 조건**:

1. **카테고리 필터**
   ```python
   products = products.filter(category__in=categories)
   ```

2. **가격 범위 필터**
   ```python
   budget_mapping = {
       'low': (0, 500000),
       'medium': (500000, 2000000),
       'high': (2000000, 10000000),
   }
   products = products.filter(price__gte=min_price, price__lte=max_price)
   ```

3. **스펙 존재 필터**
   ```python
   products = products.filter(spec__isnull=False)
   ```

4. **반려동물 필터**
   ```python
   if not has_pet:
       # 펫 관련 키워드가 있는 제품 제외
       products = products.exclude(name__icontains='펫')
   ```

**결과**: 조건에 맞는 제품만 남김 (QuerySet)

---

### 3.2 Soft Scoring (점수 계산)

**위치**: `api/services/recommendation_engine.py`의 `_score_products()` 메서드

**스코어링 함수**: `api/utils/scoring.py`의 `calculate_product_score()`

#### 3.2.1 카테고리별 가중치

```python
CATEGORY_WEIGHTS = {
    "TV": {
        "resolution": 0.25,      # 해상도
        "brightness": 0.15,      # 밝기
        "refresh_rate": 0.15,   # 주사율
        "panel_type": 0.10,      # 패널 타입
        "power_consumption": 0.10,
        "size": 0.10,
        "price_match": 0.15,
    },
    "KITCHEN": {
        "capacity": 0.25,        # 용량
        "energy_efficiency": 0.20,
        "features": 0.15,
        "size": 0.10,
        "price_match": 0.20,
        "design": 0.10,
    },
    "LIVING": {
        "audio_quality": 0.25,
        "connectivity": 0.15,
        "power_consumption": 0.10,
        "size": 0.10,
        "price_match": 0.20,
        "features": 0.20,
    },
}
```

#### 3.2.2 Priority별 가중치 조정

```python
PRIORITY_MULTIPLIERS = {
    "design": {
        "design": 1.5,      # 디자인 점수 1.5배
        "panel_type": 1.3,
        "features": 1.2,
    },
    "tech": {
        "resolution": 1.5,  # 해상도 점수 1.5배
        "refresh_rate": 1.4,
        "brightness": 1.3,
    },
    "eco": {
        "power_consumption": 1.5,
        "energy_efficiency": 1.5,
    },
    "value": {
        "price_match": 1.5,  # 가격 적합도 1.5배
        "features": 1.2,
    },
}
```

#### 3.2.3 개별 스펙 점수 계산

**해상도 점수** (`score_resolution()`):
- 4K (3840×2160): 1.0
- QHD (2560×1440): 0.8
- FHD (1920×1080): 0.6
- HD (1280×720): 0.4

**용량 점수** (`score_capacity()`):
- 가족 구성원 수 기반 적정 용량 계산
- 1인 가구: 작은 용량 선호, 큰 용량 강한 감점
- 4인 이상: 큰 용량 선호

**가격 적합도** (`score_price_match()`):
- 예산 범위 내: 높은 점수
- 예산보다 낮음: 약간 감점
- 예산보다 높음: 감점

#### 3.2.4 종합 점수 계산

```python
# 가중치 적용
total_score = 0.0
total_weight = 0.0

for key, weight in weights.items():
    if key in scores:
        multiplier = multipliers.get(key, 1.0)
        adjusted_weight = weight * multiplier
        total_score += scores[key] * adjusted_weight
        total_weight += adjusted_weight

# 정규화 (0.0 ~ 1.0)
final_score = total_score / total_weight
```

#### 3.2.5 추가 보정

**Priority별 보정**:
- tech 우선: 기술 점수 높으면 +0.05
- design 우선: 디자인 점수 높으면 +0.05
- eco 우선: 에너지 점수 높으면 +0.05
- value 우선: 가격 적합도 높으면 +0.05

**Vibe별 보정**:
- modern + 디자인 점수 높으면 +0.03
- luxury + 디자인 점수 높으면 +0.05

**가족 구성원 기반 보정**:
- 1인 가구: 작은 용량 제품 +0.15, 큰 용량 제품 -0.2
- 4인 이상: 큰 용량 제품 +0.15, 작은 용량 제품 -0.2

**반려동물 기반 보정**:
- 반려동물 있음: 펫 기능 제품 +0.2
- 반려동물 없음: 펫 기능 제품 -0.1

---

### 3.3 최종 추천 반환

**위치**: `api/services/recommendation_engine.py`의 `_format_recommendation()` 메서드

**과정**:
1. 점수 순 정렬
2. 상위 K개 선택 (기본 3개)
3. 추천 이유 생성 (`recommendation_reason_generator.py`)

**출력 형식**:
```python
{
    'success': True,
    'count': 3,
    'recommendations': [
        {
            'product_id': 1,
            'model': 'LG OLED55C5',
            'category': 'TV',
            'price': 1500000,
            'discount_price': 1200000,
            'image_url': '...',
            'score': 0.85,
            'reason': '4인 가족을 위한 모던한 디자인과 최신 기술이 결합된 제품이에요...',
        },
        ...
    ]
}
```

---

## 4. 추천 이유 생성 로직

**위치**: `api/services/recommendation_reason_generator.py`

### 4.1 우선순위

1. **취향 조합별 1:1 템플릿 매칭** (최신 추가)
   - (vibe, priority, household_category) 조합별 템플릿
   - 가장 정확한 매칭

2. **CSV의 리뷰_기반_추천문구**
   - `taste_recommendations_768.csv`에서 가져온 문구

3. **DB에 저장된 추천 이유**
   - `ProductRecommendReason` 모델

4. **리뷰 분석 기반 생성**
   - 리뷰 텍스트에서 취향 키워드 추출
   - 긍정 키워드 빈도 분석

5. **기본 문구** (점수 기반)
   - 점수에 따라 기본 문구 생성

### 4.2 취향 조합별 템플릿 예시

```python
# Modern + Tech + 1인 가구
"1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요. 
깔끔한 공간에 어울리는 컴팩트한 사이즈와 뛰어난 성능을 갖췄어요."

# Cozy + Value + 4인 가족
"4인 이상 가족을 위한 따뜻한 분위기와 넉넉한 용량, 합리적인 가격이 매력적인 제품이에요. 
가족 모두가 만족할 거예요."
```

---

## 5. 데이터 활용 현황

| 데이터 소스 | 현재 활용 | 향후 개선 |
|------------|---------|----------|
| 제품 스펙 (ProductSpec) | ✅ 활발히 사용 | - |
| 인구통계 (ProductDemographics) | ❌ 미사용 | 가족 구성원별 선호도 반영 |
| 리뷰 (ProductReview) | ✅ 추천 이유 생성에 사용 | 키워드 분석 강화 |
| 평균벡터 | ❌ 미사용 | 코사인 유사도 계산 추가 |

---

## 6. 개선 제안

### 6.1 평균벡터 활용

```python
# 취향 정보를 벡터로 변환
taste_vector = embed_taste(user_profile)

# 제품 평균벡터와 코사인 유사도 계산
similarity = cosine_similarity(taste_vector, product_vector)

# 유사도가 높은 제품에 가산점
final_score += similarity * 0.1
```

### 6.2 인구통계 데이터 활용

```python
# 가족 구성원 수와 제품 인구통계 매칭
demographics = ProductDemographics.objects.get(product=product)
preference_score = demographics.get_preference_for_household_size(household_size)

# 인구통계 점수 반영
final_score += preference_score * 0.1
```

### 6.3 머신러닝 모델 통합

- 협업 필터링 (Collaborative Filtering)
- 딥러닝 기반 추천 (Neural Collaborative Filtering)
- 강화학습 기반 추천 (Reinforcement Learning)

---

## 7. 코드 위치 요약

| 기능 | 파일 위치 |
|------|----------|
| 추천 엔진 메인 로직 | `api/services/recommendation_engine.py` |
| 스코어링 함수 | `api/utils/scoring.py` |
| 취향별 스코어링 | `api/utils/taste_scoring.py` |
| 추천 이유 생성 | `api/services/recommendation_reason_generator.py` |
| 모델 정의 | `api/models.py` |
| API 엔드포인트 | `api/views_drf.py` |

---

## 8. 테스트 방법

### 8.1 시뮬레이션 실행

```bash
python manage.py simulate_taste_recommendations \
    --csv-path data/온보딩/taste_recommendations_768.csv \
    --limit 10 \
    --output simulation_results.json
```

### 8.2 결과 분석

```bash
python manage.py visualize_simulation_results \
    --input simulation_results.json \
    --output data/온보딩/visualization
```

---

## 결론

현재 백엔드 추천 로직은 **제품 스펙과 리뷰 데이터를 활용**하여 추천을 생성하고 있습니다. 
**평균벡터와 인구통계 데이터**는 향후 개선을 통해 활용할 수 있습니다.


Step 1: 추천 엔진 인프라 확인 - 제품 데이터, 카테고리 구조, Taste-카테고리 매핑 확인


현재 상황:

- Taste 계산 및 할당 완료: 사용자 Taste ID(1-120) 계산 및 MEMBER.TASTE 저장 완료
- 온보딩 데이터 정규화 완료: ONBOARD_SESS_MAIN_SPACES, ONBOARD_SESS_PRIORITIES 테이블 준비됨


목표:

추천 엔진 실행에 필요한 모든 인프라가 준비되어 있는지 확인
- 제품 데이터 테이블 구조 확인
- 카테고리 테이블 구조 확인
- Taste ID와 카테고리의 매핑 관계 확인
- 예산/조건 필터링에 필요한 필드 확인
- 제품-카테고리 관계 확인


검증 항목:

1. 제품 데이터 테이블 확인
   - 제품 테이블 이름 및 구조 확인
   - 제품 ID, 이름, 가격, 카테고리, 이미지 등 필수 필드 존재 여부
   - 제품 상태 필드 (판매 중/단종 등) 존재 여부
   - 제품 상세 정보 필드 확인

2. 카테고리 테이블 확인
   - 카테고리 테이블 이름 및 구조 확인
   - 카테고리 ID, 이름, 계층 구조 등 필드 확인
   - 카테고리별 제품 수 확인

3. Taste-카테고리 매핑 확인
   - Taste ID(1-120)와 카테고리 간 매핑 테이블/로직 존재 여부
   - 각 Taste ID가 어떤 카테고리와 연결되는지 확인
   - 매핑 데이터의 완전성 확인 (모든 Taste ID에 매핑이 있는지)

4. 제품-카테고리 관계 확인
   - 제품과 카테고리 간 연결 테이블/필드 확인
   - 한 제품이 여러 카테고리에 속할 수 있는지 확인
   - 카테고리별 제품 조회 방법 확인

5. 예산/조건 필터링 필드 확인
   - 제품 가격 필드 확인
   - 예산 범위 필터링 가능 여부 확인
   - 온보딩 조건(예: 펫, 요리 빈도 등)과 제품 속성 매칭 가능 여부 확인

6. 인덱스 및 성능 확인
   - 카테고리별 제품 조회를 위한 인덱스 존재 여부
   - 가격 범위 검색을 위한 인덱스 존재 여부
   - 조회 성능을 위한 최적화 확인


관련 파일 (예상):

- api/db/oracle_client.py
  - DB 연결 및 쿼리 실행 함수

- api/services/recommendation_service.py (존재 여부 확인 필요)
  - 추천 엔진 메인 서비스

- 제품 관련 테이블 (테이블명 확인 필요)
  - PRODUCT, ITEM, GOODS 등

- 카테고리 관련 테이블 (테이블명 확인 필요)
  - CATEGORY, PRODUCT_CATEGORY 등

- Taste-카테고리 매핑 테이블/로직 (확인 필요)
  - TASTE_CATEGORY_MAPPING 등


작업:

1. DB 스키마 조사:
   - 제품 관련 테이블 목록 조회
   - 카테고리 관련 테이블 목록 조회
   - Taste-카테고리 매핑 테이블/로직 확인
   - 각 테이블의 컬럼 구조 확인

2. 데이터 존재 여부 확인:
   - 제품 데이터 레코드 수 확인
   - 카테고리 데이터 레코드 수 확인
   - Taste-카테고리 매핑 데이터 확인
   - 각 카테고리별 제품 수 확인

3. 관계 확인:
   - 제품-카테고리 관계 구조 확인
   - Taste-카테고리 매핑 구조 확인
   - 예산/조건 필터링 가능한 필드 확인

4. 인덱스 확인:
   - 주요 조회 쿼리에 사용될 인덱스 확인
   - 성능 최적화를 위한 인덱스 필요 여부 확인

5. 문서화:
   - 발견된 테이블 구조 문서화
   - 관계 구조 다이어그램 작성
   - 매핑 로직 문서화


검증 방법:

1. 테이블 구조 조회:
   ```sql
   -- 제품 테이블 조회
   SELECT * FROM USER_TABLES WHERE TABLE_NAME LIKE '%PRODUCT%' OR TABLE_NAME LIKE '%ITEM%';
   
   -- 카테고리 테이블 조회
   SELECT * FROM USER_TABLES WHERE TABLE_NAME LIKE '%CATEGORY%';
   
   -- 각 테이블의 컬럼 구조 확인
   SELECT COLUMN_NAME, DATA_TYPE, NULLABLE FROM USER_TAB_COLUMNS WHERE TABLE_NAME = '테이블명';
   ```

2. 데이터 존재 확인:
   ```sql
   -- 제품 수 확인
   SELECT COUNT(*) FROM 제품테이블;
   
   -- 카테고리 수 확인
   SELECT COUNT(*) FROM 카테고리테이블;
   
   -- 카테고리별 제품 수 확인
   SELECT 카테고리ID, COUNT(*) FROM 제품테이블 GROUP BY 카테고리ID;
   ```

3. Taste-카테고리 매핑 확인:
   ```sql
   -- 매핑 테이블이 있는 경우
   SELECT * FROM TASTE_CATEGORY_MAPPING;
   
   -- 또는 코드에서 매핑 로직 확인
   ```

4. 관계 확인:
   ```sql
   -- 제품-카테고리 관계 확인
   SELECT p.제품ID, c.카테고리ID 
   FROM 제품테이블 p 
   JOIN 관계테이블 r ON p.제품ID = r.제품ID
   JOIN 카테고리테이블 c ON r.카테고리ID = c.카테고리ID;
   ```


예상 결과:

1. 제품 데이터 테이블:
   - 제품 테이블 존재 확인
   - 필수 필드 (ID, 이름, 가격, 카테고리) 모두 존재
   - 제품 데이터 레코드 수 확인 (최소 수백 개 이상 권장)

2. 카테고리 테이블:
   - 카테고리 테이블 존재 확인
   - 카테고리 계층 구조 또는 플랫 구조 확인
   - 카테고리 수 확인

3. Taste-카테고리 매핑:
   - 매핑 테이블 또는 로직 존재 확인
   - 모든 Taste ID(1-120)에 대한 매핑 존재
   - 각 Taste ID가 최소 1개 이상의 카테고리와 연결

4. 제품-카테고리 관계:
   - 관계 구조 명확히 확인
   - 카테고리별 제품 조회 가능 확인

5. 예산/조건 필터링:
   - 가격 필드 존재 확인
   - 예산 범위 필터링 가능 확인
   - 조건 매칭 가능한 필드 확인


테스트 스크립트 구조:

```python
class RecommendationInfrastructureValidator:
    """추천 엔진 인프라 확인 클래스"""
    
    def validate_all(self):
        """모든 인프라 확인 실행"""
        # 1. 제품 데이터 테이블 확인
        # 2. 카테고리 테이블 확인
        # 3. Taste-카테고리 매핑 확인
        # 4. 제품-카테고리 관계 확인
        # 5. 예산/조건 필터링 필드 확인
        # 6. 인덱스 및 성능 확인
    
    def _validate_product_tables(self):
        """제품 데이터 테이블 확인"""
    
    def _validate_category_tables(self):
        """카테고리 테이블 확인"""
    
    def _validate_taste_category_mapping(self):
        """Taste-카테고리 매핑 확인"""
    
    def _validate_product_category_relationship(self):
        """제품-카테고리 관계 확인"""
    
    def _validate_filtering_fields(self):
        """예산/조건 필터링 필드 확인"""
    
    def _check_indexes(self):
        """인덱스 확인"""
    
    def _document_findings(self):
        """발견 사항 문서화"""
```


시각화 항목:

1. 테이블 구조 다이어그램
2. 제품-카테고리 관계 다이어그램
3. Taste-카테고리 매핑 분포
4. 카테고리별 제품 수 분포
5. 제품 가격 분포


참고:

- Taste 계산이 완료되었으므로 MEMBER.TASTE 값이 존재하는 회원 데이터 활용 가능
- 온보딩 데이터의 예산/조건 정보 활용 가능
- 실제 운영 환경의 데이터 구조를 정확히 파악하는 것이 중요
- 추후 단계에서 사용할 테이블/필드 정보를 명확히 문서화 필요


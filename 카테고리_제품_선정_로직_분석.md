# 카테고리 선정 및 제품 선정 로직 분석

## 1. 카테고리 선정 로직 (`api/utils/taste_category_selector.py`)

### 현재 상태
- **점수 기반이 아님**: 카테고리 선정에는 수치상의 점수가 없습니다
- **규칙 기반 선정**: 온보딩 데이터를 기반으로 규칙에 따라 선택

### 선정 프로세스

#### Step 1: 필수 카테고리 선택
```python
필수 카테고리 = ['TV', '냉장고', '에어컨', '세탁']
```
- Oracle DB의 PRODUCT 테이블에서 제품 수가 많은 상위 카테고리
- 항상 포함됨 (최소 3개)

#### Step 2: 카테고리 개수 결정
```python
기본값 = 3개 (필수 카테고리)

if household_size >= 4:
    개수 += 1  # 대가족이면 +1

if budget_level in ['high', 'premium', 'luxury']:
    개수 += 1  # 높은 예산이면 +1

if pyung >= 40:
    개수 += 1  # 큰 평수면 +1

최대 7개로 제한
```

#### Step 3: 추가 카테고리 선택
온보딩 데이터 기반 우선순위 결정:

1. **미디어 사용이 높으면**: 에어컨 관련 카테고리 우선
   - `media in ['high', 'gaming']` → 에어컨, 공기청정기 등

2. **디자인 우선순위면**: 프리미엄 라인업 우선
   - `priority contains 'design'` → (현재는 OBJET, SIGNATURE가 DB에 없음)

3. **기술 우선순위면**: AI 관련 카테고리 우선
   - `priority contains 'tech' or 'ai'` → AIHome 등

4. **나머지**: 제품 수가 많은 순서대로 선택

### Taste별 차이점
- **taste_id는 카테고리 선정에 직접 사용되지 않음**
- **온보딩 데이터만 사용**: vibe, priority, budget_level, household_size, pyung, media 등
- 같은 온보딩 데이터면 같은 카테고리가 선택됨

---

## 2. 제품 선정 로직 (`api/services/taste_based_recommendation_engine.py`)

### 선정 프로세스

#### Step 1: 카테고리별 제품 필터링
```python
Oracle DB에서 직접 쿼리:
- MAIN_CATEGORY = 선택된 카테고리
- STATUS = '판매중'
- PRICE > 0 AND PRICE IS NOT NULL
- PRICE >= min_price AND PRICE <= max_price (예산 범위)
```

#### Step 2: 카테고리별 제품 스코어링
```python
각 제품에 대해:
1. Django Product 모델에서 가져오기 (PRODUCT_ID 기준)
2. Taste 기반 동적 Scoring Logic 적용
   - calculate_product_score_with_taste_logic() 호출
   - taste_id와 onboarding_data 기반으로 가중치, 보너스, 페널티 적용
3. 최종 점수 계산 (0.0 ~ 1.0)
```

#### Step 3: 카테고리별 상위 3개 선택
```python
각 카테고리에서:
- 점수 내림차순 정렬
- 상위 3개 선택
```

---

## 3. Taste별 제품 스코어링 로직 차이 (`api/utils/dynamic_taste_scoring.py`)

### Taste별 차이점

#### 1. 가중치 조정
온보딩 데이터 기반으로 각 속성의 가중치가 동적으로 조정됩니다:

**Vibe 기반:**
- `modern`: 디자인 가중치 ×1.3, 기능 가중치 ×1.2, 가격 가중치 ×0.8
- `luxury`: 디자인 가중치 ×1.5, 기능 가중치 ×1.3, 가격 가중치 ×0.6
- `cozy`: 가격 가중치 ×1.3, 전력소비 가중치 ×1.2, 디자인 가중치 ×0.9

**Priority 기반:**
- `design`: 디자인 가중치 ×1.5
- `tech`: 기능 가중치 ×1.5, 해상도 가중치 ×1.3
- `value`: 가격 매칭 가중치 ×1.5, 에너지 효율 가중치 ×1.2
- `eco`: 에너지 효율 가중치 ×1.5, 전력소비 가중치 ×1.5

**Budget 기반:**
- `low`: 가격 매칭 가중치 ×1.5, 디자인 가중치 ×0.7
- `high`: 디자인 가중치 ×1.3, 기능 가중치 ×1.3, 가격 가중치 ×0.7

**Household Size 기반:**
- `>= 4인`: 용량 가중치 ×1.5, 기능 가중치 ×1.2
- `1인`: 용량 가중치 ×0.7, 크기 가중치 ×1.3

**평수 기반:**
- `<= 20평`: 크기 가중치 ×0.8, 용량 가중치 ×0.8
- `>= 40평`: 크기 가중치 ×1.3, 용량 가중치 ×1.3

**생활 패턴 기반:**
- `cooking = daily`: 주방가전 기능 가중치 ×1.3, 용량 가중치 ×1.2
- `laundry = daily`: 생활가전 기능 가중치 ×1.2, 용량 가중치 ×1.2
- `media = high`: TV 해상도 가중치 ×1.4, 밝기 가중치 ×1.3

#### 2. 보너스/페널티 적용
```python
보너스:
- 디자인 우선순위 + OBJET/SIGNATURE 라인업 → +0.15
- 기술 우선순위 + AI/스마트 기능 → +0.15
- 대가족 + 대용량 제품 → +0.12
- 높은 예산 + 프리미엄 기능 → +0.10

페널티:
- 대가족 + 소형 제품 → -0.2
- 소형 주택 + 대형 제품 → -0.15
- 낮은 예산 + 고가 제품 → -0.15
```

### Taste별 차이 요약

| 항목 | 카테고리 선정 | 제품 선정 |
|------|-------------|----------|
| **점수 사용** | ❌ 없음 (규칙 기반) | ✅ 있음 (0.0~1.0) |
| **taste_id 사용** | ❌ 사용 안 함 | ✅ 사용 (동적 scoring logic 생성) |
| **온보딩 데이터 사용** | ✅ 사용 (카테고리 개수, 우선순위 결정) | ✅ 사용 (가중치 조정, 보너스/페널티) |
| **차별화 방식** | 온보딩 데이터 기반 규칙 | taste_id + 온보딩 데이터 기반 동적 가중치 |

---

## 4. 문제점 및 개선 방안

### 현재 문제점

1. **카테고리 선정에 taste_id 미사용**
   - 같은 온보딩 데이터면 항상 같은 카테고리 선택
   - taste별 차별화 부족

2. **카테고리 선정에 점수 없음**
   - 각 카테고리에 대한 적합도 점수가 없음
   - 단순 규칙 기반 선택

3. **제품 선정에서 카테고리별 차별화 부족**
   - 모든 카테고리에 동일한 가중치 템플릿 사용
   - Oracle DB의 실제 MAIN_CATEGORY (TV, 냉장고, 세탁 등)에 맞는 가중치 필요

### 카테고리 매핑 문제

**현재 상황:**
- Oracle DB의 실제 MAIN_CATEGORY: `TV`, `냉장고`, `에어컨`, `세탁`, `김치냉장고`, `가습기`, `공기청정기` 등
- 제품 스코어링에서 사용하는 카테고리: `TV`, `KITCHEN`, `LIVING`, `default`
- **매핑 로직**: Django Product 모델의 `category` 필드가 `TV`, `KITCHEN`, `LIVING` 중 하나가 아니면 `default`로 매핑

**문제점:**
- Oracle DB의 `냉장고`, `세탁`, `김치냉장고` 등이 `KITCHEN`으로 매핑되지 않을 수 있음
- `에어컨`, `공기청정기`, `가습기` 등이 `LIVING`으로 매핑되지 않을 수 있음
- 대부분의 카테고리가 `default` 가중치를 사용하게 됨

### 개선 방안

1. **카테고리 선정에 점수 도입**
   - 각 카테고리에 대한 적합도 점수 계산
   - taste_id 기반으로 카테고리별 가중치 적용

2. **taste_id를 카테고리 선정에 활용**
   - taste_id 기반으로 카테고리 선호도 매핑
   - 온보딩 데이터 + taste_id 조합으로 더 정교한 선택

3. **카테고리별 가중치 템플릿 확장**
   - Oracle DB의 실제 MAIN_CATEGORY에 맞는 가중치 템플릿 추가
   - 예: '냉장고', '세탁', '김치냉장고' 등에 대한 별도 가중치
   - Oracle DB MAIN_CATEGORY → 스코어링 카테고리 매핑 로직 개선

4. **카테고리 매핑 로직 개선**
   - Oracle DB의 MAIN_CATEGORY를 스코어링 카테고리로 매핑하는 함수 추가
   - 예: `냉장고`, `김치냉장고` → `KITCHEN`, `세탁` → `LIVING`, `에어컨`, `공기청정기` → `LIVING`


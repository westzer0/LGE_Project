Step 3: Taste 계산 로직 검증 - TasteClassifier가 올바른 Taste ID(1~120)를 반환하는지 테스트



현재 상황:

- Step 1 완료: 모든 필수 인프라 준비됨 (테이블, 컬럼, 제약조건 확인 완료)
- Step 2 완료: 온보딩 데이터 조회 로직 검증 완료 (_get_onboarding_data_from_session() 정상 작동 확인)
- 실제 DB에 ONBOARDING_SESSION 레코드 1,056개 존재
- 정규화 테이블 (ONBOARD_SESS_MAIN_SPACES, ONBOARD_SESS_PRIORITIES) 생성 완료



목표:

TasteClassifier.calculate_taste_from_onboarding() 메서드가 올바르게 작동하는지 검증



검증 항목:

1. 입력 데이터 형식 검증
   - 온보딩 데이터 딕셔너리가 올바른 형식인지 확인
   - 필수 필드 존재 여부 확인
   - 선택 필드 기본값 처리 확인

2. Taste ID 범위 검증
   - 반환값이 1~120 범위 내인지 확인
   - 모든 테스트 케이스에서 범위를 벗어나지 않는지 확인

3. 일관성 검증
   - 동일한 입력에 대해 항상 동일한 Taste ID를 반환하는지 확인
   - 해시 기반 계산의 일관성 확인

4. 다양한 입력 조합 검증
   - 다양한 vibe, household_size, priority 조합 테스트
   - NULL 값 처리 확인
   - 빈 배열 처리 확인
   - 경계값 테스트 (최소/최대 값)

5. 실제 세션 데이터로 검증
   - Step 2에서 검증한 실제 SESSION_ID로 Taste 계산 테스트
   - 계산된 Taste ID가 올바른 범위에 있는지 확인

6. 분포 검증
   - 다양한 입력에 대해 Taste ID 분포가 적절한지 확인
   - 특정 Taste ID에 과도하게 집중되지 않는지 확인



관련 파일:

- api/utils/taste_classifier.py (라인 24~105)
  - calculate_taste_from_onboarding() 메서드
  - TASTE_COUNT = 120 (1~120 범위)
  - 해시 기반 계산 로직

- api/services/taste_calculation_service.py (라인 13~55)
  - calculate_and_save_taste() 메서드
  - TasteClassifier 호출 및 범위 검증 로직

- test_taste_data_retrieval.py (Step 2 테스트 스크립트 참고)



작업:

1. test_taste_calculation.py 테스트 스크립트 작성

2. 테스트 케이스 작성:
   - 기본 케이스: 모든 필드가 채워진 정상 데이터
   - NULL 값 케이스: 일부 필드가 NULL인 경우
   - 빈 배열 케이스: main_space, priority가 빈 배열인 경우
   - 경계값 케이스: 최소/최대 값 테스트
   - 다양한 조합: vibe, household_size, priority 등의 다양한 조합

3. 실제 세션 데이터로 검증:
   - Step 2에서 사용한 실제 SESSION_ID 20개로 테스트
   - 각 세션의 온보딩 데이터를 조회하여 Taste 계산
   - 계산된 Taste ID가 1~120 범위인지 확인

4. 일관성 테스트:
   - 동일한 입력 데이터로 여러 번 계산하여 동일한 결과 반환 확인

5. 분포 분석:
   - 다양한 입력에 대해 계산된 Taste ID의 분포 확인
   - 히스토그램으로 분포 시각화

6. 시각화 생성:
   - Taste ID 분포 히스토그램
   - 입력 속성별 Taste ID 분포
   - 검증 결과 요약 차트



예상 반환 형식:

taste_id: int (1 ~ 120 범위의 정수)

예시:
- 입력: {
    'vibe': 'modern',
    'household_size': 4,
    'housing_type': 'apartment',
    'pyung': 30,
    'budget_level': 'medium',
    'priority': ['tech', 'design'],
    'main_space': ['living', 'kitchen'],
    'has_pet': False,
    'cooking': 'frequently',
    'laundry': 'weekly',
    'media': 'balanced'
  }
- 출력: 45 (1~120 범위의 정수)



검증 방법:

1. 단위 테스트:
   - 각 테스트 케이스를 개별적으로 실행
   - 반환값이 1~120 범위인지 확인
   - 예외가 발생하지 않는지 확인

2. 통합 테스트:
   - 실제 SESSION_ID로 전체 플로우 테스트
   - _get_onboarding_data_from_session() → calculate_taste_from_onboarding() 연계 테스트

3. 일관성 테스트:
   - 동일 입력으로 100회 반복 계산
   - 모든 결과가 동일한지 확인

4. 분포 테스트:
   - 다양한 입력 조합 100개 생성
   - 계산된 Taste ID의 분포 확인
   - 각 Taste ID(1~120)가 최소 1번 이상 나타나는지 확인 (선택적)

5. 시각화:
   - Taste ID 분포 히스토그램
   - 입력 속성별 Taste ID 분포 (vibe별, household_size별 등)
   - 검증 결과 요약 (통과/실패 비율)



참고:

- TasteClassifier.TASTE_COUNT = 120 (1~120 범위)
- 해시 기반 계산이므로 동일 입력에 대해 항상 동일한 결과 반환
- NULL 값이나 누락된 필드는 기본값으로 처리됨
- Step 2에서 검증한 실제 SESSION_ID 샘플 활용 가능
- test_taste_data_retrieval.py의 구조를 참고하여 작성


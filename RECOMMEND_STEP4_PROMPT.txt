Step 4: 예산/조건 기반 제품 필터링 검증 - 온보딩 데이터의 예산 및 조건으로 제품 필터링 검증


현재 상황:

- Step 1 완료: 추천 엔진 인프라 확인 완료
- Step 2 완료: Taste 기반 카테고리 선택 로직 검증 완료
- Step 3 완료: 카테고리별 제품 조회 로직 검증 완료
- 온보딩 데이터에 예산 및 조건 정보 존재 (BUDGET_LEVEL, HAS_PET, COOKING 등)


목표:

온보딩 데이터의 예산 및 조건 정보를 기반으로 제품을 필터링하는 로직이 올바르게 작동하는지 검증
- 예산 범위 기반 제품 필터링 검증
- 조건 기반 제품 필터링 검증 (펫, 요리 빈도 등)
- 필터링된 제품이 조건을 만족하는지 확인


검증 항목:

1. 예산 기반 필터링 검증
   - BUDGET_LEVEL (low, medium, high 등) 또는 예산 금액으로 제품 필터링
   - 필터링된 제품의 가격이 예산 범위 내인지 확인
   - 예산 범위 계산 로직 검증

2. 조건 기반 필터링 검증
   - HAS_PET: 펫이 있는 경우 펫 관련 제품 필터링
   - COOKING: 요리 빈도에 따른 주방 제품 필터링
   - LAUNDRY: 세탁 빈도에 따른 세탁기/건조기 필터링
   - MEDIA: 미디어 사용 패턴에 따른 TV/오디오 제품 필터링
   - 각 조건이 제품 속성과 올바르게 매칭되는지 확인

3. 복합 조건 필터링 검증
   - 여러 조건을 동시에 적용하는 경우 처리 확인
   - 예산 + 조건 조합 필터링 검증
   - 필터링 결과가 모든 조건을 만족하는지 확인

4. 실제 온보딩 데이터로 검증
   - 실제 완료된 온보딩 세션의 예산/조건 정보 사용
   - 각 세션의 조건으로 제품 필터링 테스트
   - 필터링된 제품이 조건을 만족하는지 확인

5. 빈 결과 처리 검증
   - 조건을 만족하는 제품이 없는 경우 처리 확인
   - 예산이 너무 낮아 제품이 없는 경우 처리 확인

6. 경계값 검증
   - 최소 예산으로 필터링
   - 최대 예산으로 필터링
   - 경계값 처리 확인


관련 파일 (예상):

- api/services/recommendation_service.py
  - filter_products_by_budget() 메서드 (예상)
  - filter_products_by_conditions() 메서드 (예상)
  - 제품 목록과 예산/조건을 입력받아 필터링된 제품 반환

- api/services/taste_calculation_service.py
  - _get_onboarding_data_from_session() 메서드
  - 온보딩 데이터 조회 (예산/조건 정보 포함)

- 제품 테이블
  - 가격 필드
  - 제품 속성 필드 (펫 관련, 주방 관련 등)


작업:

1. 예산/조건 필터링 로직 찾기:
   - 코드베이스에서 필터링 로직 검색
   - 예산 필터링 함수/메서드 확인
   - 조건 필터링 함수/메서드 확인

2. 예산 필터링 검증:
   - BUDGET_LEVEL별 예산 범위 확인
   - 예산 범위로 제품 필터링 테스트
   - 필터링된 제품 가격 검증

3. 조건 필터링 검증:
   - 각 조건(HAS_PET, COOKING 등)별 필터링 테스트
   - 제품 속성과 조건 매칭 확인
   - 필터링 결과 검증

4. 복합 조건 필터링 검증:
   - 예산 + 여러 조건 조합 테스트
   - 필터링 결과가 모든 조건 만족하는지 확인

5. 실제 온보딩 데이터로 검증:
   - 완료된 온보딩 세션 100개 이상 선택
   - 각 세션의 예산/조건으로 제품 필터링
   - 필터링 결과 검증

6. 시각화 생성:
   - 예산별 필터링된 제품 수 분포
   - 조건별 필터링된 제품 수 분포
   - 필터링 전후 제품 수 비교


검증 방법:

1. 예산 필터링 테스트:
   ```python
   # 예산 레벨로 예산 범위 계산
   budget_level = 'medium'
   budget_range = calculate_budget_range(budget_level)
   # 예: {'min': 1000000, 'max': 5000000}
   
   # 제품 목록 필터링
   products = get_products_by_category(category_id)
   filtered_products = filter_products_by_budget(products, budget_range)
   
   # 필터링된 제품의 가격이 예산 범위 내인지 확인
   for product in filtered_products:
       assert budget_range['min'] <= product['price'] <= budget_range['max']
   ```

2. 조건 필터링 테스트:
   ```python
   # 펫 조건 필터링
   has_pet = True
   products = get_products_by_category(category_id)
   filtered_products = filter_products_by_condition(products, 'has_pet', has_pet)
   
   # 필터링된 제품이 펫 관련인지 확인
   for product in filtered_products:
       assert product.get('pet_friendly', False) == True
   ```

3. 복합 조건 필터링 테스트:
   ```python
   # 예산 + 조건 조합
   onboarding_data = {
       'budget_level': 'medium',
       'has_pet': True,
       'cooking': 'frequently'
   }
   
   products = get_products_by_categories(category_ids)
   
   # 예산 필터링
   budget_range = calculate_budget_range(onboarding_data['budget_level'])
   filtered = filter_products_by_budget(products, budget_range)
   
   # 조건 필터링
   if onboarding_data['has_pet']:
       filtered = filter_products_by_condition(filtered, 'has_pet', True)
   if onboarding_data['cooking'] == 'frequently':
       filtered = filter_products_by_condition(filtered, 'cooking', 'frequently')
   
   # 모든 조건 만족 확인
   for product in filtered:
       assert budget_range['min'] <= product['price'] <= budget_range['max']
       if onboarding_data['has_pet']:
           assert product.get('pet_friendly', False) == True
   ```

4. 실제 온보딩 데이터 테스트:
   ```python
   # 완료된 온보딩 세션 조회
   completed_sessions = get_completed_sessions(limit=100)
   
   for session in completed_sessions:
       # 온보딩 데이터 조회
       onboarding_data = _get_onboarding_data_from_session(session['session_id'])
       
       # 카테고리 선택 (Step 2)
       taste_id = get_taste_for_member(session['member_id'])
       categories = get_categories_for_taste(taste_id)
       
       # 제품 조회 (Step 3)
       products = get_products_by_categories([c['id'] for c in categories])
       
       # 예산/조건 필터링
       budget_range = calculate_budget_range(onboarding_data.get('budget_level'))
       filtered = filter_products_by_budget(products, budget_range)
       
       # 조건별 필터링
       if onboarding_data.get('has_pet'):
           filtered = filter_products_by_condition(filtered, 'has_pet', True)
       # ... 기타 조건
       
       # 필터링 결과 검증
       assert len(filtered) >= 0  # 최소 0개 이상 (제품이 없을 수도 있음)
       for product in filtered:
           # 예산 조건 만족 확인
           assert budget_range['min'] <= product['price'] <= budget_range['max']
   ```


예상 결과:

1. 예산 필터링:
   - 예산 범위 내의 제품만 필터링됨
   - 필터링된 모든 제품의 가격이 예산 범위 내
   - 예산 범위 계산 로직이 올바름

2. 조건 필터링:
   - 각 조건에 맞는 제품만 필터링됨
   - 제품 속성과 조건이 올바르게 매칭됨
   - 필터링 결과가 조건을 만족함

3. 복합 조건:
   - 모든 조건을 만족하는 제품만 필터링됨
   - 필터링 결과가 예산과 모든 조건을 만족함

4. 실제 데이터:
   - 대부분의 온보딩 세션에 대해 필터링 성공
   - 필터링된 제품이 조건을 만족함
   - 일부 세션은 조건을 만족하는 제품이 없을 수 있음 (정상)


테스트 스크립트 구조:

```python
class BudgetConditionFilteringValidator:
    """예산/조건 기반 제품 필터링 검증 클래스"""
    
    def validate_all(self):
        """모든 검증 실행"""
        # 1. 예산 기반 필터링 검증
        # 2. 조건 기반 필터링 검증
        # 3. 복합 조건 필터링 검증
        # 4. 실제 온보딩 데이터로 검증
        # 5. 빈 결과 처리 검증
        # 6. 경계값 검증
    
    def _validate_budget_filtering(self):
        """예산 기반 필터링 검증"""
    
    def _validate_condition_filtering(self):
        """조건 기반 필터링 검증"""
        # HAS_PET, COOKING, LAUNDRY, MEDIA 등
    
    def _validate_combined_filtering(self):
        """복합 조건 필터링 검증"""
    
    def _validate_with_real_onboarding_data(self):
        """실제 온보딩 데이터로 검증"""
        # 완료된 온보딩 세션 사용
    
    def _validate_empty_results(self):
        """빈 결과 처리 검증"""
    
    def _validate_boundary_values(self):
        """경계값 검증"""
    
    def _calculate_budget_range(self, budget_level):
        """예산 레벨로 예산 범위 계산"""
```


시각화 항목:

1. 예산별 필터링된 제품 수 분포 바 차트
2. 조건별 필터링된 제품 수 분포 바 차트
3. 필터링 전후 제품 수 비교
4. 예산 범위별 제품 가격 분포
5. 조건 만족률 (조건을 만족하는 제품이 있는 세션 비율)


참고:

- 온보딩 데이터의 예산/조건 정보 활용
- Step 2, 3에서 검증한 카테고리 선택 및 제품 조회 결과 활용
- 제품 속성과 온보딩 조건의 매핑 관계 명확히 정의 필요
- 예산 범위 계산 로직이 비즈니스 요구사항과 일치하는지 확인


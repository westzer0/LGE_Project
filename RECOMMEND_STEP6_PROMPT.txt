Step 6: 추천 엔진 통합 테스트 - Taste ID부터 최종 추천 결과까지 전체 플로우 통합 검증


현재 상황:

- Step 1 완료: 추천 엔진 인프라 확인 완료
- Step 2 완료: Taste 기반 카테고리 선택 로직 검증 완료
- Step 3 완료: 카테고리별 제품 조회 로직 검증 완료
- Step 4 완료: 예산/조건 기반 제품 필터링 검증 완료
- Step 5 완료: 추천 결과 포맷팅 및 반환 검증 완료
- 각 단계별 로직이 개별적으로 검증 완료


목표:

Taste ID부터 최종 추천 결과까지 전체 플로우가 올바르게 작동하는지 통합 테스트
- 전체 플로우 실행 검증
- 각 단계 간 데이터 전달 검증
- 최종 추천 결과의 정확성 검증
- 성능 검증


검증 항목:

1. 전체 플로우 통합 검증
   - Taste ID 조회 → 카테고리 선택 → 제품 조회 → 필터링 → 포맷팅 → 반환 전체 플로우 테스트
   - 각 단계가 올바르게 연결되는지 확인
   - 중간 단계에서 에러가 발생하지 않는지 확인

2. 실제 회원 데이터로 검증
   - MEMBER 테이블에서 TASTE 값이 있는 회원 100명 이상 선택
   - 각 회원에 대해 전체 플로우 실행
   - 최종 추천 결과 검증

3. 온보딩 데이터 연계 검증
   - 온보딩 완료된 회원의 세션 데이터 활용
   - 온보딩 데이터의 예산/조건 정보가 필터링에 올바르게 사용되는지 확인

4. 데이터 일관성 검증
   - 동일한 회원에 대해 여러 번 추천 요청 시 일관된 결과 확인
   - 추천 결과가 Taste ID와 온보딩 데이터와 일치하는지 확인

5. 성능 검증
   - 전체 플로우 실행 시간 측정
   - 각 단계별 소요 시간 측정
   - 병목 구간 식별

6. 에러 처리 검증
   - 각 단계에서 에러 발생 시 적절한 처리 확인
   - 에러 발생 시 다른 단계에 영향이 없는지 확인
   - 에러 메시지가 적절한지 확인

7. 엣지 케이스 검증
   - TASTE 값이 없는 회원 처리
   - 온보딩 데이터가 없는 회원 처리
   - 필터링 후 제품이 없는 경우 처리
   - 카테고리에 제품이 없는 경우 처리


관련 파일:

- api/services/recommendation_service.py
  - get_recommendations() 메서드
  - 전체 추천 플로우 실행

- api/services/taste_calculation_service.py
  - get_taste_for_member() 메서드
  - _get_onboarding_data_from_session() 메서드

- api/views.py
  - recommendation_view() 함수
  - 추천 API 엔드포인트

- api/services/onboarding_db_service.py
  - 온보딩 세션 데이터 조회


작업:

1. 전체 플로우 통합 테스트:
   - Taste ID 조회부터 최종 결과 반환까지 전체 실행
   - 각 단계별 데이터 검증

2. 실제 회원 데이터로 검증:
   - MEMBER 테이블에서 TASTE 값이 있는 회원 100명 이상 선택
   - 각 회원에 대해 전체 플로우 실행
   - 결과 검증

3. 온보딩 데이터 연계 검증:
   - 온보딩 완료된 회원의 세션 데이터 활용
   - 예산/조건 정보가 올바르게 사용되는지 확인

4. 성능 측정:
   - 전체 플로우 실행 시간 측정
   - 각 단계별 평균 처리 시간 계산
   - 병목 구간 식별

5. 에러 처리 테스트:
   - 각 단계에서 에러 발생 시뮬레이션
   - 에러 처리 확인

6. 엣지 케이스 테스트:
   - 다양한 엣지 케이스 테스트
   - 적절한 처리 확인

7. 시각화 생성:
   - 전체 플로우 성공/실패 비율
   - 단계별 처리 시간 분포
   - 추천 결과 통계
   - 에러 발생 빈도


검증 방법:

1. 전체 플로우 통합 테스트:
   ```python
   # 회원 ID로 전체 플로우 실행
   member_id = 'user_123'
   
   # 1. Taste ID 조회
   taste_id = get_taste_for_member(member_id)
   assert taste_id is not None
   assert 1 <= taste_id <= 120
   
   # 2. 온보딩 데이터 조회 (예산/조건 정보)
   onboarding_session = get_latest_completed_session(member_id)
   onboarding_data = _get_onboarding_data_from_session(onboarding_session['session_id'])
   
   # 3. 카테고리 선택
   categories = get_categories_for_taste(taste_id)
   assert len(categories) > 0
   
   # 4. 제품 조회
   products = get_products_by_categories([c['id'] for c in categories])
   assert len(products) > 0
   
   # 5. 예산/조건 필터링
   budget_range = calculate_budget_range(onboarding_data.get('budget_level'))
   filtered_products = filter_products_by_budget(products, budget_range)
   # 조건별 필터링...
   
   # 6. 추천 결과 포맷팅
   recommendations = format_recommendation_results(filtered_products, categories)
   
   # 7. 최종 검증
   assert 'categories' in recommendations
   assert len(recommendations['categories']) > 0
   ```

2. 실제 회원 데이터 테스트:
   ```python
   # MEMBER 테이블에서 TASTE 값이 있는 회원 조회
   members = get_members_with_taste(limit=100)
   
   success_count = 0
   error_count = 0
   
   for member in members:
       member_id = member['member_id']
       try:
           # 전체 플로우 실행
           recommendations = get_recommendations(member_id)
           
           # 결과 검증
           assert 'categories' in recommendations or 'products' in recommendations
           success_count += 1
       except Exception as e:
           error_count += 1
           print(f"Error for member {member_id}: {e}")
   
   # 성공률 확인
   success_rate = success_count / len(members)
   assert success_rate >= 0.9  # 최소 90% 성공률
   ```

3. 성능 측정:
   ```python
   import time
   
   members = get_members_with_taste(limit=50)
   execution_times = []
   
   for member in members:
       start_time = time.time()
       recommendations = get_recommendations(member['member_id'])
       end_time = time.time()
       
       execution_time = end_time - start_time
       execution_times.append(execution_time)
   
   # 평균 실행 시간 계산
   avg_time = sum(execution_times) / len(execution_times)
   print(f"Average execution time: {avg_time:.2f} seconds")
   
   # 최대 실행 시간 확인
   max_time = max(execution_times)
   assert max_time < 5.0  # 최대 5초 이내
   ```

4. 에러 처리 테스트:
   ```python
   # TASTE 값이 없는 회원
   member_id_no_taste = 'user_no_taste'
   try:
       recommendations = get_recommendations(member_id_no_taste)
       # 기본 추천 또는 에러 처리 확인
   except Exception as e:
       # 적절한 에러 메시지 확인
       assert 'taste' in str(e).lower() or 'not found' in str(e).lower()
   ```


예상 플로우:

```
1. 회원 ID 입력
   ↓
2. MEMBER 테이블에서 TASTE 값 조회
   ↓
3. 온보딩 세션에서 예산/조건 정보 조회
   ↓
4. Taste ID로 카테고리 선택
   ↓
5. 선택된 카테고리로 제품 조회
   ↓
6. 예산/조건으로 제품 필터링
   ↓
7. 카테고리별 제품 그룹화 및 상위 제품 선택
   ↓
8. 추천 결과 포맷팅
   ↓
9. API 응답 반환
```


예상 결과:

1. 전체 플로우:
   - 모든 단계가 올바르게 연결됨
   - 중간 단계에서 에러 발생 없음
   - 최종 추천 결과가 올바른 형식

2. 실제 데이터:
   - 90% 이상의 회원에 대해 추천 성공
   - 추천된 제품이 사용자에게 유용함
   - 추천 결과가 Taste ID와 온보딩 데이터와 일치함

3. 성능:
   - 평균 실행 시간 < 2초
   - 최대 실행 시간 < 5초
   - 대부분의 요청이 3초 이내 완료

4. 에러 처리:
   - 에러 발생 시 적절한 에러 메시지 반환
   - 에러가 다른 요청에 영향 없음
   - 로깅이 적절히 됨


테스트 스크립트 구조:

```python
class RecommendationIntegrationValidator:
    """추천 엔진 통합 테스트 클래스"""
    
    def validate_all(self):
        """모든 검증 실행"""
        # 1. 전체 플로우 통합 검증
        # 2. 실제 회원 데이터로 검증 (100명 이상)
        # 3. 온보딩 데이터 연계 검증
        # 4. 데이터 일관성 검증
        # 5. 성능 검증
        # 6. 에러 처리 검증
        # 7. 엣지 케이스 검증
    
    def _validate_full_flow(self):
        """전체 플로우 통합 검증"""
    
    def _validate_with_real_members(self):
        """실제 회원 데이터로 검증"""
        # MEMBER 테이블에서 TASTE 값이 있는 회원 100명 이상
    
    def _validate_onboarding_integration(self):
        """온보딩 데이터 연계 검증"""
    
    def _validate_data_consistency(self):
        """데이터 일관성 검증"""
    
    def _measure_performance(self):
        """성능 측정"""
    
    def _validate_error_handling(self):
        """에러 처리 검증"""
    
    def _validate_edge_cases(self):
        """엣지 케이스 검증"""
```


시각화 항목:

1. 전체 플로우 성공/실패 비율 파이 차트
2. 단계별 처리 시간 박스 플롯
3. 추천 결과 통계 (카테고리별 제품 수, 평균 제품 수 등)
4. 에러 발생 빈도 바 차트
5. 성능 메트릭 (평균/최대 실행 시간)
6. 회원별 추천 결과 샘플


참고:

- Step 1~5에서 검증한 모든 로직이 통합되어 작동하는지 확인
- 실제 운영 환경과 동일한 조건으로 테스트
- 성능은 사용자 경험에 직접적인 영향이 있으므로 중요
- 에러 처리는 시스템 안정성에 중요
- test_taste_integration.py의 구조를 참고하여 작성


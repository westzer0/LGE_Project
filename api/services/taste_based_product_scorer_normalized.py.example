"""
정규화된 TASTE_CONFIG 구조를 사용하는 예시 코드

이 파일은 정규화 후의 코드 구조를 보여주는 예시입니다.
실제 적용 시 taste_based_product_scorer.py를 이 구조로 업데이트하세요.
"""
from typing import Dict, List, Optional
from api.db.oracle_connection import get_connection
import logging

logger = logging.getLogger(__name__)


class TasteBasedProductScorerNormalized:
    """
    정규화된 TASTE_CONFIG 테이블을 사용하는 제품 스코어링 서비스
    """
    
    def _get_taste_config(self, taste_id: int) -> Optional[Dict]:
        """
        정규화된 테이블에서 TasteConfig 조회
        
        변경사항:
        - 기존: JSON 컬럼 파싱
        - 신규: JOIN을 통한 효율적인 데이터 조회
        """
        try:
            with get_connection() as conn:
                with conn.cursor() as cur:
                    # 1. 기본 Taste 정보 조회
                    cur.execute("""
                        SELECT 
                            TASTE_ID,
                            REPRESENTATIVE_VIBE,
                            REPRESENTATIVE_HOUSEHOLD_SIZE,
                            REPRESENTATIVE_MAIN_SPACE,
                            REPRESENTATIVE_HAS_PET,
                            REPRESENTATIVE_PRIORITY,
                            REPRESENTATIVE_BUDGET_LEVEL
                        FROM TASTE_CONFIG
                        WHERE TASTE_ID = :p_taste_id
                    """, {'p_taste_id': taste_id})
                    
                    row = cur.fetchone()
                    if not row:
                        return None
                    
                    # 2. 카테고리별 점수 조회 (정규화된 테이블)
                    cur.execute("""
                        SELECT 
                            CATEGORY_NAME,
                            SCORE,
                            IS_RECOMMENDED,
                            IS_ILL_SUITED
                        FROM TASTE_CATEGORY_SCORES
                        WHERE TASTE_ID = :p_taste_id
                        ORDER BY SCORE DESC
                    """, {'p_taste_id': taste_id})
                    
                    category_scores = {}
                    recommended_categories = []
                    ill_suited_categories = []
                    
                    for cat_row in cur.fetchall():
                        category_name = cat_row[0]
                        score = cat_row[1]
                        is_recommended = cat_row[2] == 'Y'
                        is_ill_suited = cat_row[3] == 'Y'
                        
                        category_scores[category_name] = score
                        if is_recommended:
                            recommended_categories.append(category_name)
                        if is_ill_suited:
                            ill_suited_categories.append(category_name)
                    
                    # 3. 추천 제품 조회 (정규화된 테이블)
                    cur.execute("""
                        SELECT 
                            CATEGORY_NAME,
                            PRODUCT_ID,
                            SCORE,
                            RANK_ORDER
                        FROM TASTE_RECOMMENDED_PRODUCTS
                        WHERE TASTE_ID = :p_taste_id
                        ORDER BY CATEGORY_NAME, RANK_ORDER
                    """, {'p_taste_id': taste_id})
                    
                    recommended_products = {}
                    recommended_product_scores = {}
                    
                    for prod_row in cur.fetchall():
                        category_name = prod_row[0]
                        product_id = prod_row[1]
                        score = prod_row[2]
                        rank = prod_row[3]
                        
                        if category_name not in recommended_products:
                            recommended_products[category_name] = []
                            recommended_product_scores[category_name] = []
                        
                        recommended_products[category_name].append(product_id)
                        recommended_product_scores[category_name].append(score)
                    
                    return {
                        'taste_id': row[0],
                        'representative_vibe': row[1],
                        'representative_household_size': row[2],
                        'representative_main_space': row[3],
                        'representative_has_pet': row[4] == 'Y' if row[4] else False,
                        'representative_priority': row[5],
                        'representative_budget_level': row[6],
                        'recommended_categories': recommended_categories,
                        'category_scores': category_scores,
                        'ill_suited_categories': ill_suited_categories,
                        'recommended_products': recommended_products,
                        'recommended_product_scores': recommended_product_scores
                    }
                    
        except Exception as e:
            logger.error(f"Error fetching TasteConfig for taste_id={taste_id}: {str(e)}", exc_info=True)
            return None
    
    def _get_category_score(self, taste_id: int, category: str) -> float:
        """
        특정 카테고리의 점수만 조회 (성능 최적화)
        
        장점:
        - 필요한 카테고리만 조회하여 불필요한 데이터 로딩 방지
        - 인덱스 활용으로 빠른 조회
        """
        try:
            with get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        SELECT SCORE
                        FROM TASTE_CATEGORY_SCORES
                        WHERE TASTE_ID = :p_taste_id
                          AND CATEGORY_NAME = :p_category
                    """, {
                        'p_taste_id': taste_id,
                        'p_category': category
                    })
                    
                    row = cur.fetchone()
                    return float(row[0]) if row and row[0] is not None else 0.0
                    
        except Exception as e:
            logger.error(f"Error fetching category score: {str(e)}", exc_info=True)
            return 0.0
    
    def _get_recommended_products_for_category(
        self, taste_id: int, category: str, limit: int = 3
    ) -> List[Dict]:
        """
        특정 카테고리의 추천 제품만 조회 (성능 최적화)
        
        장점:
        - 필요한 카테고리와 제품만 조회
        - RANK_ORDER로 정렬되어 있어 추가 정렬 불필요
        """
        try:
            with get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        SELECT 
                            PRODUCT_ID,
                            SCORE,
                            RANK_ORDER
                        FROM TASTE_RECOMMENDED_PRODUCTS
                        WHERE TASTE_ID = :p_taste_id
                          AND CATEGORY_NAME = :p_category
                        ORDER BY RANK_ORDER
                        FETCH FIRST :p_limit ROWS ONLY
                    """, {
                        'p_taste_id': taste_id,
                        'p_category': category,
                        'p_limit': limit
                    })
                    
                    products = []
                    for row in cur.fetchall():
                        products.append({
                            'product_id': row[0],
                            'score': row[1],
                            'rank': row[2]
                        })
                    
                    return products
                    
        except Exception as e:
            logger.error(f"Error fetching recommended products: {str(e)}", exc_info=True)
            return []
    
    def _is_category_recommended(self, taste_id: int, category: str) -> bool:
        """
        카테고리가 추천 카테고리인지 확인 (간단한 조회)
        """
        try:
            with get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        SELECT COUNT(*)
                        FROM TASTE_CATEGORY_SCORES
                        WHERE TASTE_ID = :p_taste_id
                          AND CATEGORY_NAME = :p_category
                          AND IS_RECOMMENDED = 'Y'
                    """, {
                        'p_taste_id': taste_id,
                        'p_category': category
                    })
                    
                    return cur.fetchone()[0] > 0
                    
        except Exception as e:
            logger.error(f"Error checking recommended category: {str(e)}", exc_info=True)
            return False
    
    def _is_category_ill_suited(self, taste_id: int, category: str) -> bool:
        """
        카테고리가 부적합 카테고리인지 확인
        """
        try:
            with get_connection() as conn:
                with conn.cursor() as cur:
                    cur.execute("""
                        SELECT COUNT(*)
                        FROM TASTE_CATEGORY_SCORES
                        WHERE TASTE_ID = :p_taste_id
                          AND CATEGORY_NAME = :p_category
                          AND IS_ILL_SUITED = 'Y'
                    """, {
                        'p_taste_id': taste_id,
                        'p_category': category
                    })
                    
                    return cur.fetchone()[0] > 0
                    
        except Exception as e:
            logger.error(f"Error checking ill-suited category: {str(e)}", exc_info=True)
            return False


# 사용 예시
if __name__ == '__main__':
    scorer = TasteBasedProductScorerNormalized()
    
    # 전체 Taste Config 조회
    config = scorer._get_taste_config(taste_id=1)
    print(f"Recommended categories: {config['recommended_categories']}")
    print(f"Category scores: {config['category_scores']}")
    
    # 특정 카테고리 점수만 조회 (성능 최적화)
    tv_score = scorer._get_category_score(taste_id=1, category='TV')
    print(f"TV score: {tv_score}")
    
    # 특정 카테고리의 추천 제품만 조회
    tv_products = scorer._get_recommended_products_for_category(taste_id=1, category='TV', limit=3)
    print(f"TV recommended products: {tv_products}")
    
    # 카테고리 추천 여부 확인
    is_recommended = scorer._is_category_recommended(taste_id=1, category='TV')
    print(f"Is TV recommended: {is_recommended}")




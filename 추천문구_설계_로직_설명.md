# 추천문구 칼럼 설계 로직 설명

## 📋 개요

`taste_recommendations_768.csv` 파일에는 두 가지 추천문구 칼럼이 있습니다:
- **리뷰_기반_추천문구**: 실제 구매자 리뷰를 분석하여 생성
- **AI_기반_추천문구**: AI가 생성한 문구

이 문서는 이 추천문구들이 어떻게 생성되고, 추천 로직에서 어떻게 활용되는지 설명합니다.

---

## 🎯 추천문구의 목적

사용자에게 **"왜 이 제품을 추천하는가?"**를 설명하기 위한 문구입니다.

예를 들어:
- ❌ 단순히: "이 제품을 추천합니다"
- ✅ 개인화: "1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요. 깔끔한 공간에 어울리는 컴팩트한 사이즈와 뛰어난 성능을 갖췄어요."

---

## 📊 두 가지 추천문구의 차이

### 1. 리뷰_기반_추천문구

**생성 방법:**
- 실제 구매자들이 작성한 리뷰를 분석
- 해당 취향 조합(taste_id)에 맞는 제품들의 리뷰를 수집
- 리뷰에서 자주 언급되는 키워드와 긍정 피드백을 추출
- 이를 바탕으로 추천 문구 생성

**특징:**
- ✅ **신뢰도 높음**: 실제 구매자의 경험 기반
- ✅ **구체적**: 실제 사용 경험을 반영
- ⚠️ **제한적**: 리뷰가 없는 제품/취향 조합은 생성 어려움

**예시:**
```
"혼자만의 모던 & 미니멀 무드

인테리어를 완성하는 디자인을 중시하는 당신을 위해
LG 트롬 오브제컬렉션 세탁기21kg1등급를 골라봤어요.

리뷰에서 역시, 조용하고, 세탁, 가전은, 있어 등의 긍정적 피드백이 많았어요.

500만원 미만 (실속형) 예산으로 완벽한 조합을 제안합니다."
```

### 2. AI_기반_추천문구

**생성 방법:**
- AI(예: ChatGPT)가 취향 정보를 분석
- 취향 조합의 특성을 파악
- 제품 정보와 취향을 결합하여 문구 생성

**특징:**
- ✅ **창의적**: 다양한 표현 가능
- ✅ **완전성**: 리뷰가 없어도 생성 가능
- ⚠️ **신뢰도**: 실제 경험 기반이 아님

**예시:**
```
"모던 & 미니멀 감성으로 채우는 혼자만의 공간

깔끔하고 세련된 디자인을 중시하는 당신을 위해
LG 트롬 오브제컬렉션 세탁기21kg1등급를 추천드려요.

미니멀한 인테리어에 완벽하게 어울리는 디자인과
실용적인 기능을 갖춘 제품입니다."
```

---

## 🔄 추천문구 생성 및 사용 흐름

### Step 1: CSV 파일 생성 (초기 설정)

```
1. 취향 조합 데이터 수집
   └─ 768개 취향 조합 정의

2. 리뷰_기반_추천문구 생성
   ├─ 각 취향 조합에 맞는 제품 리뷰 수집
   ├─ 리뷰 분석 (키워드 추출, 긍정 피드백 분석)
   └─ 문구 생성

3. AI_기반_추천문구 생성
   ├─ 취향 정보를 AI에 전달
   ├─ AI가 문구 생성
   └─ 검토 및 수정

4. CSV 파일 저장
   └─ taste_recommendations_768.csv
```

### Step 2: 실시간 추천 시 사용 (런타임)

```
사용자 온보딩 완료
    ↓
taste_id 찾기 (취향 조합 매칭)
    ↓
CSV에서 해당 taste_id의 행 가져오기
    ↓
추천문구 생성 로직 실행 (우선순위 적용)
    ↓
최종 추천문구 반환
```

---

## 🎯 추천문구 생성 우선순위

실제 추천 시에는 다음 우선순위로 문구를 선택합니다:

### **0순위: 취향 조합별 1:1 템플릿 매칭** (가장 정확)

코드에 하드코딩된 템플릿을 사용합니다.

```python
# 예시: (modern, tech, single) 조합
"1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요."
```

**장점:**
- 가장 정확한 매칭
- 빠른 응답 속도

**단점:**
- 제한된 조합만 지원
- 모든 취향 조합 커버 불가

### **1순위: CSV의 리뷰_기반_추천문구** ⭐ (주로 사용)

CSV 파일의 `리뷰_기반_추천문구` 칼럼을 사용합니다.

```python
if taste_info and taste_info.get('리뷰_기반_추천문구'):
    base_reason = taste_info['리뷰_기반_추천문구']
    # 개인화 처리
    personalized = self._personalize_reason(base_reason, user_profile, product)
    return personalized
```

**개인화 처리:**
- 사용자 정보 추가 (예: "1인 가구에 적합한 당신을 위해, ...")
- 우선순위 정보 추가 (예: "디자인을 중시하는 당신을 위해, ...")
- 문구 길이 조정 (100자 초과 시 요약)

### **2순위: DB에 저장된 추천 이유**

제품별로 DB에 저장된 추천 이유를 사용합니다.

```python
if hasattr(product, 'recommend_reason') and product.recommend_reason:
    db_reason = product.recommend_reason.reason_text
    personalized = self._personalize_reason(db_reason, user_profile, product)
    return personalized
```

### **3순위: 리뷰 분석 기반 생성**

실시간으로 제품 리뷰를 분석하여 문구를 생성합니다.

```python
review_based = self._generate_from_reviews(product, user_profile, taste_info)
```

**과정:**
1. 제품 리뷰 수집 (최대 20개)
2. 취향 키워드 추출 (vibe, priority 등)
3. 리뷰에서 취향 키워드 매칭
4. 긍정 키워드 추출
5. 문구 생성

### **4순위: 기본 문구** (Fallback)

위 모든 방법이 실패하면 기본 문구를 사용합니다.

```python
if score >= 0.8:
    return "당신의 선호도(디자인)에 가장 잘 맞는 제품입니다."
elif score >= 0.6:
    return "우수한 성능과 가성비를 갖춘 제품입니다."
else:
    return "조건에 맞는 추천 제품입니다."
```

---

## 🔧 개인화 처리 로직

CSV에서 가져온 추천문구는 **개인화 처리**를 거칩니다.

### 개인화 요소 추가

```python
def _personalize_reason(base_reason, user_profile, product):
    personalization = []
    
    # 가족 구성원 정보
    if household_size == 1:
        personalization.append("1인 가구에 적합한")
    elif household_size >= 4:
        personalization.append(f"{household_size}인 가족에 적합한")
    
    # 우선순위 정보
    if priority == 'design' and '디자인' not in base_reason:
        personalization.append("디자인을 중시하는")
    # ... 기타 우선순위
    
    # 개인화 요소 추가
    if personalization:
        prefix = " ".join(personalization) + " 당신을 위해, "
        return prefix + base_reason
```

### 예시

**원본 문구:**
```
"LG 트롬 오브제컬렉션 세탁기를 추천드려요.
리뷰에서 조용하고, 세탁 기능이 뛰어나다는 긍정적 피드백이 많았어요."
```

**개인화 후:**
```
"1인 가구에 적합한 디자인을 중시하는 당신을 위해, 
LG 트롬 오브제컬렉션 세탁기를 추천드려요.
리뷰에서 조용하고, 세탁 기능이 뛰어나다는 긍정적 피드백이 많았어요."
```

---

## 📈 추천문구 생성 시나리오

### 시나리오 1: 정상 케이스 (가장 일반적)

```
1. 사용자 온보딩 완료
   └─ taste_id: 1 (모던 & 미니멀, 1인 가구, 디자인 우선, 500만원 미만)

2. CSV에서 taste_id=1 행 가져오기
   └─ 리뷰_기반_추천문구: "혼자만의 모던 & 미니멀 무드..."

3. 개인화 처리
   └─ "1인 가구에 적합한 디자인을 중시하는 당신을 위해, 혼자만의 모던 & 미니멀 무드..."

4. 최종 반환
   └─ 사용자에게 표시
```

### 시나리오 2: 템플릿 매칭 케이스

```
1. 사용자 온보딩 완료
   └─ (modern, tech, single) 조합

2. 코드의 템플릿 매칭
   └─ "1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요."

3. 제품 정보로 개인화
   └─ "1인 가구를 위한 미니멀한 디자인과 최신 기술이 결합된 제품이에요. 
       선명한 화질로 몰입감 있는 시청이 가능해요." (TV인 경우)

4. 최종 반환
```

### 시나리오 3: 리뷰 분석 케이스 (CSV 문구 없음)

```
1. 사용자 온보딩 완료
   └─ taste_id: 999 (새로운 취향 조합, CSV에 없음)

2. CSV 문구 없음 → 리뷰 분석으로 전환

3. 제품 리뷰 수집
   └─ 최대 20개 리뷰

4. 취향 키워드 추출
   └─ ['모던', '미니멀', '디자인', '세련']

5. 리뷰에서 키워드 매칭
   └─ '디자인': 5회, '세련': 3회

6. 문구 생성
   └─ "리뷰에서 '디자인'에 대한 긍정적 피드백이 5회 이상 나타났습니다."

7. 최종 반환
```

### 시나리오 4: Fallback 케이스

```
1. 사용자 온보딩 완료

2. CSV 문구 없음
3. DB 추천 이유 없음
4. 리뷰 없음

5. 기본 문구 사용
   └─ "당신의 선호도(디자인)에 가장 잘 맞는 제품입니다."

6. 최종 반환
```

---

## 💡 설계 철학

### 1. **계층적 Fallback 구조**

```
정확도 높음 ←────────────────────→ 정확도 낮음
템플릿 → CSV → DB → 리뷰분석 → 기본문구
```

각 단계가 실패하면 다음 단계로 넘어갑니다.

### 2. **개인화 우선**

모든 문구는 사용자 정보로 개인화됩니다:
- 가족 구성원 수
- 우선순위
- 예산 범위
- 인테리어 스타일

### 3. **실제 데이터 기반**

가능한 한 실제 구매자 리뷰를 활용하여 신뢰도를 높입니다.

### 4. **성능 최적화**

- 리뷰 캐싱
- 템플릿 우선 사용
- CSV 파일 한 번 로드

---

## 🔍 코드에서의 실제 사용

### 추천 엔진에서 호출

```python
# api/services/recommendation_engine.py
def _format_recommendation(self, item, user_profile, taste_id=None, taste_info=None):
    # ...
    reason = reason_generator.generate_reason(
        product=product,
        user_profile=user_profile,
        taste_info=taste_info,  # ← CSV 행 전체를 dict로 전달
        score=score
    )
    return {
        'product_id': product.id,
        'reason': reason,  # ← 최종 추천문구
        # ...
    }
```

### CSV 데이터 전달

```python
# api/management/commands/simulate_taste_recommendations.py
taste_info = {
    'taste_id': row.get('taste_id'),
    '인테리어_스타일': row.get('인테리어_스타일'),
    '메이트_구성': row.get('메이트_구성'),
    '우선순위': row.get('우선순위'),
    '예산_범위': row.get('예산_범위'),
    '선호_라인업': row.get('선호_라인업'),
    '리뷰_기반_추천문구': row.get('리뷰_기반_추천문구'),  # ← 여기!
    'AI_기반_추천문구': row.get('AI_기반_추천문구'),      # ← 여기!
}

result = engine.get_recommendations(
    user_profile=user_profile,
    taste_id=taste_id,
    taste_info=taste_info  # ← 전달
)
```

---

## 📊 추천문구 품질 관리

### 1. **리뷰_기반_추천문구 생성 시**

- 최소 리뷰 수 확인 (예: 10개 이상)
- 긍정/부정 리뷰 비율 확인
- 키워드 빈도 분석
- 문구 길이 제한 (너무 길면 요약)

### 2. **AI_기반_추천문구 생성 시**

- 프롬프트 최적화
- 생성된 문구 검토
- 일관성 유지

### 3. **실시간 검증**

- 문구 길이 확인 (너무 짧거나 길면 조정)
- 개인화 요소 확인
- 제품 정보 일치 확인

---

## 🎯 핵심 정리

1. **두 가지 추천문구**
   - 리뷰_기반: 실제 구매자 경험 기반 (신뢰도 높음)
   - AI_기반: AI 생성 (창의적, 완전성)

2. **우선순위 구조**
   - 템플릿 → CSV 리뷰_기반 → DB → 리뷰분석 → 기본문구

3. **개인화 필수**
   - 모든 문구는 사용자 정보로 개인화됨

4. **Fallback 메커니즘**
   - 각 단계 실패 시 다음 단계로 자동 전환

5. **성능 최적화**
   - 캐싱, 템플릿 우선 사용

---

## ❓ 자주 묻는 질문

### Q1. 리뷰_기반과 AI_기반 중 어떤 것을 주로 사용하나요?
A: **리뷰_기반을 우선 사용**합니다. 신뢰도가 높기 때문입니다. AI_기반은 리뷰가 없거나 부족할 때 보조적으로 사용됩니다.

### Q2. 추천문구는 언제 생성되나요?
A: 
- **CSV 문구**: 사전에 생성되어 CSV 파일에 저장
- **템플릿**: 코드에 하드코딩
- **리뷰 분석**: 실시간 생성
- **기본 문구**: 실시간 생성

### Q3. 새로운 취향 조합이 추가되면?
A: CSV 파일에 새로운 행을 추가하고, 리뷰_기반_추천문구와 AI_기반_추천문구를 생성하면 됩니다.

### Q4. 추천문구를 수정하려면?
A: CSV 파일의 해당 행을 수정하거나, 코드의 템플릿을 수정하면 됩니다.

---

## 📚 관련 파일

- `api/services/recommendation_reason_generator.py`: 추천문구 생성 로직
- `api/services/recommendation_engine.py`: 추천 엔진 (문구 호출)
- `data/온보딩/taste_recommendations_768.csv`: 추천문구 데이터
- `api/management/commands/generate_taste_recommendations.py`: 추천문구 생성 스크립트

